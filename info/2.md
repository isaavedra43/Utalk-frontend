
### üìã Fase 4: Chat en Tiempo Real

#### 4.1 Componente de Chat
```svelte
<!-- src/routes/conversation/[id]/+page.svelte -->
<script lang="ts">
  import { onMount, onDestroy } from 'svelte';
  import { page } from '$app/stores';
  import { api } from '$lib/services/axios';
  import { socketManager } from '$lib/services/socket';
  import { validateMessage, validateFileUpload } from '$lib/utils/validation';
  import { safeDateToISOString } from '$lib/utils/dates';
  
  let messages: Message[] = [];
  let conversation: Conversation | null = null;
  let newMessage = '';
  let selectedFiles: File[] = [];
  let loading = true;
  let error = '';
  let canSend = false;

  $: conversationId = $page.params.id;

  onMount(async () => {
    await loadConversation();
    await loadMessages();
    setupSocketListeners();
    loading = false;
  });

  onDestroy(() => {
    // Limpiar listeners
    socketManager.socket?.off('new-message');
    socketManager.socket?.off('message-status-updated');
  });

  async function loadConversation() {
    try {
      const response = await api.get(`/conversations/${conversationId}`);
      conversation = response.data;
      canSend = conversation.assignedTo !== null;
    } catch (err: any) {
      error = err.response?.data?.message || 'Error al cargar conversaci√≥n';
    }
  }

  async function loadMessages() {
    try {
      const response = await api.get(`/conversations/${conversationId}/messages`);
      messages = response.data;
    } catch (err: any) {
      error = 'Error al cargar mensajes';
    }
  }

  function setupSocketListeners() {
    socketManager.socket?.on('new-message', (message: Message) => {
      if (message.conversationId === conversationId) {
        messages = [...messages, message];
      }
    });

    socketManager.socket?.on('message-status-updated', (data: any) => {
      messages = messages.map(msg => 
        msg.id === data.messageId 
          ? { ...msg, status: data.status, metadata: data.metadata }
          : msg
      );
    });
  }

  function handleFileSelect(event: Event) {
    const target = event.target as HTMLInputElement;
    const files = Array.from(target.files || []);
    
    const validation = validateFileUpload(files);
    if (!validation.valid) {
      error = validation.error || 'Error en archivos';
      return;
    }
    
    selectedFiles = files;
  }

  async function sendMessage() {
    const validation = validateMessage(newMessage);
    if (!validation.valid) {
      error = validation.error || 'Error en mensaje';
      return;
    }

    if (!canSend) {
      error = 'No puedes enviar mensajes a esta conversaci√≥n';
      return;
    }

    try {
      const formData = new FormData();
      formData.append('text', newMessage);
      
      selectedFiles.forEach(file => {
        formData.append('attachments', file);
      });

      const response = await api.post(`/conversations/${conversationId}/messages`, formData);
      
      // El mensaje se agregar√° autom√°ticamente via socket
      newMessage = '';
      selectedFiles = [];
      error = '';
    } catch (err: any) {
      error = err.response?.data?.message || 'Error al enviar mensaje';
    }
  }

  function renderMessage(message: Message) {
    const isOwnMessage = message.sender === 'current-user';
    const date = safeDateToISOString(message.timestamp);
    
    return (
      <div class="message" class:own={isOwnMessage} class:failed={message.status === 'failed'}>
        <div class="message-content">
          <p>{message.text}</p>
          {message.metadata?.failureReason && (
            <div class="error-message">
              {message.metadata.failureReason}
              {message.metadata.retryable && (
                <button class="retry-button">Reintentar</button>
              )}
            </div>
          )}
        </div>
        <div class="message-time">
          {date ? new Date(date).toLocaleTimeString() : 'Hora no disponible'}
        </div>
      </div>
    );
  }
</script>

<div class="chat-container">
  {#if loading}
    <div class="loading">Cargando conversaci√≥n...</div>
  {:else if error}
    <div class="error">{error}</div>
  {:else if !conversation}
    <div class="error">Conversaci√≥n no encontrada</div>
  {:else}
    <div class="chat-header">
      <h2>{conversation.contact?.name || conversation.contact?.phone || 'Sin nombre'}</h2>
      {#if !conversation.assignedTo}
        <div class="warning">Sin agente asignado - No se pueden enviar mensajes</div>
      {/if}
    </div>

    <div class="messages-container">
      {#each messages as message}
        {renderMessage(message)}
      {/each}
    </div>

    <div class="message-input" class:disabled={!canSend}>
      <textarea 
        bind:value={newMessage}
        placeholder={canSend ? "Escribe tu mensaje..." : "Asigna un agente para enviar mensajes"}
        disabled={!canSend}
        maxlength="4096"
      />
      
      <input 
        type="file" 
        multiple 
        accept="image/*,audio/*,video/*,.pdf"
        on:change={handleFileSelect}
        disabled={!canSend}
      />
      
      <button on:click={sendMessage} disabled={!canSend || !newMessage.trim()}>
        Enviar
      </button>
    </div>
  {/if}
</div>

### üìã Fase 5: Manejo de Errores y Estados Especiales

#### 5.1 Componente de Notificaciones
```svelte
<!-- src/lib/components/Notification.svelte -->
<script lang="ts">
  import { createEventDispatcher } from 'svelte';
  
  export let type: 'success' | 'error' | 'warning' | 'info' = 'info';
  export let message: string = '';
  export let duration: number = 5000;
  
  const dispatch = createEventDispatcher();
  
  let visible = true;
  
  if (duration > 0) {
    setTimeout(() => {
      visible = false;
      dispatch('close');
    }, duration);
  }
</script>

{#if visible}
  <div class="notification" class:notification-{type}>
    <span class="message">{message}</span>
    <button class="close-button" on:click={() => visible = false}>
      √ó
    </button>
  </div>
{/if}

<style>
  .notification {
    padding: 1rem;
    border-radius: 4px;
    margin: 0.5rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  
  .notification-success { background-color: #d4edda; color: #155724; }
  .notification-error { background-color: #f8d7da; color: #721c24; }
  .notification-warning { background-color: #fff3cd; color: #856404; }
  .notification-info { background-color: #d1ecf1; color: #0c5460; }
</style>
```

#### 5.2 Store de Notificaciones
```javascript
// src/lib/stores/notifications.store.ts
import { writable } from 'svelte/store';

interface Notification {
  id: string;
  type: 'success' | 'error' | 'warning' | 'info';
  message: string;
  duration?: number;
}

const createNotificationsStore = () => {
  const { subscribe, update } = writable<Notification[]>([]);

  return {
    subscribe,
    add: (notification: Omit<Notification, 'id'>) => {
      const id = Date.now().toString();
      update(notifications => [...notifications, { ...notification, id }]);
    },
    remove: (id: string) => {
      update(notifications => notifications.filter(n => n.id !== id));
    },
    success: (message: string, duration?: number) => {
      this.add({ type: 'success', message, duration });
    },
    error: (message: string, duration?: number) => {
      this.add({ type: 'error', message, duration });
    },
    warning: (message: string, duration?: number) => {
      this.add({ type: 'warning', message, duration });
    },
    info: (message: string, duration?: number) => {
      this.add({ type: 'info', message, duration });
    }
  };
};

export const notificationsStore = createNotificationsStore();
```

### üìã Fase 6: Testing y Validaci√≥n

#### 6.1 Tests de Integraci√≥n
```javascript
// src/tests/integration/auth.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { api } from '$lib/services/axios';

describe('Authentication Integration', () => {
  beforeEach(() => {
    localStorage.clear();
  });

  it('should login with valid credentials', async () => {
    const response = await api.post('/auth/login', {
      email: 'admin@company.com',
      password: '123456'
    });

    expect(response.status).toBe(200);
    expect(response.data).toHaveProperty('token');
    expect(response.data).toHaveProperty('user');
  });

  it('should handle invalid credentials', async () => {
    try {
      await api.post('/auth/login', {
        email: 'invalid@email.com',
        password: 'wrongpassword'
      });
    } catch (error: any) {
      expect(error.response.status).toBe(401);
    }
  });
});
```

#### 6.2 Tests de Validaci√≥n
```javascript
// src/tests/unit/validation.test.ts
import { describe, it, expect } from 'vitest';
import { validatePhone, validateMessage, validateFileUpload } from '$lib/utils/validation';

describe('Validation Utils', () => {
  describe('validatePhone', () => {
    it('should validate correct phone numbers', () => {
      expect(validatePhone('+521234567890')).toBe(true);
      expect(validatePhone('+1234567890')).toBe(true);
    });

    it('should reject invalid phone numbers', () => {
      expect(validatePhone('1234567890')).toBe(false);
      expect(validatePhone('+123')).toBe(false);
      expect(validatePhone('abc')).toBe(false);
    });
  });

  describe('validateMessage', () => {
    it('should accept valid messages', () => {
      const result = validateMessage('Hello world');
      expect(result.valid).toBe(true);
    });

    it('should reject messages too long', () => {
      const longMessage = 'a'.repeat(4097);
      const result = validateMessage(longMessage);
      expect(result.valid).toBe(false);
      expect(result.error).toContain('4096');
    });
  });
});
```

#### 6.3 Tests de Flujo Completo
```javascript
// src/tests/e2e/complete-flow.test.ts
describe('Complete User Flow', () => {
  it('should complete login ‚Üí chat ‚Üí logout flow', async () => {
    // 1. Login
    const loginResponse = await api.post('/auth/login', {
      email: 'admin@company.com',
      password: '123456'
    });
    expect(loginResponse.status).toBe(200);

    // 2. Load conversations
    const conversationsResponse = await api.get('/conversations');
    expect(conversationsResponse.status).toBe(200);

    // 3. Send message (if conversation exists)
    if (conversationsResponse.data.length > 0) {
      const conversationId = conversationsResponse.data[0].id;
      const messageResponse = await api.post(`/conversations/${conversationId}/messages`, {
        text: 'Test message'
      });
      expect(messageResponse.status).toBe(201);
    }

    // 4. Logout
    const logoutResponse = await api.post('/auth/logout');
    expect(logoutResponse.status).toBe(200);
  });

  it('should handle token expiration during long operations', async () => {
    // Simular expiraci√≥n de token durante upload de archivo grande
    // Verificar que se maneje TOKEN_EXPIRED_DURING_PROCESSING
  });

  it('should handle multiple users sending messages simultaneously', async () => {
    // Simular m√∫ltiples usuarios enviando mensajes al mismo tiempo
    // Verificar que no haya conflictos
  });
});
```

### üìã Fase 7: Monitoreo y M√©tricas

#### 7.1 Monitoreo de Rate Limiting
```javascript
// src/lib/services/monitoring.ts
class RateLimitMonitor {
  private warnings = new Set<string>();

  handleRateLimitHeaders(response: any) {
    const remaining = response.headers['X-RateLimit-Remaining'];
    const reset = response.headers['X-RateLimit-Reset'];
    
    if (remaining < 5 && !this.warnings.has('rate-limit')) {
      this.showWarning('Est√°s cerca del l√≠mite de peticiones');
      this.warnings.add('rate-limit');
    }
  }

  private showWarning(message: string) {
    // Mostrar notificaci√≥n al usuario
    notificationsStore.warning(message);
  }
}
```

#### 7.2 Performance Monitoring
```javascript
// src/lib/services/performance.ts
class PerformanceMonitor {
  trackApiCall(endpoint: string, duration: number) {
    console.log(`API Call to ${endpoint}: ${duration}ms`);
    
    if (duration > 5000) {
      console.warn(`Slow API call detected: ${endpoint}`);
    }
  }

  trackError(error: any) {
    console.error('API Error:', {
      status: error.response?.status,
      message: error.response?.data?.message,
      endpoint: error.config?.url,
      timestamp: new Date().toISOString()
    });
  }
}
```

---

## üéØ CONCLUSI√ìN

Este plan completo asegura que el frontend de UTalk est√© **100% alineado con el backend** y maneje correctamente todos los casos especiales, validaciones y estados que el sistema requiere.

### ‚úÖ Puntos Clave a Recordar:
1. **Usar siempre datos reales** - NO inventar informaci√≥n
2. **Seguir la documentaci√≥n del backend** como fuente √∫nica de verdad
3. **Implementar todas las validaciones** del lado cliente
4. **Manejar todos los edge cases** documentados
5. **No duplicar l√≥gica de negocio** en el frontend
6. **Probar con APIs reales** desde el primer d√≠a

### üöÄ Pr√≥ximos Pasos:
1. Implementar la configuraci√≥n base (Fase 1)
2. Desarrollar autenticaci√≥n (Fase 2)
3. Crear gesti√≥n de conversaciones (Fase 3)
4. Implementar chat en tiempo real (Fase 4)
5. Agregar manejo de errores (Fase 5)
6. Realizar testing completo (Fase 6)
7. Implementar monitoreo y m√©tricas (Fase 7)

### üìã Checklist Final de Verificaci√≥n
- [ ] **Configuraci√≥n de entornos** correcta
- [ ] **Headers de autorizaci√≥n** implementados
- [ ] **Validaciones de emojis** funcionando
- [ ] **Rate limiting** del lado cliente
- [ ] **Eventos de escritura** con debounce
- [ ] **Logs detallados** para debugging
- [ ] **Tests de flujo completo** pasando
- [ ] **Monitoreo de performance** activo
- [ ] **Manejo de errores** espec√≠ficos
- [ ] **Datos reales** en todas las pruebas

### üéØ Resultado Esperado
Siguiendo este plan completo, el frontend de UTalk estar√° **100% alineado con el backend**, manejando todos los casos especiales, validaciones y estados que el sistema requiere, sin inventar datos y trabajando siempre con informaci√≥n real del backend.

Siguiendo este plan paso a paso, el frontend quedar√° preparado para integrarse perfectamente con el backend actual y futuro de UTalk.


### üìã Fase 3: Gesti√≥n de Conversaciones (Continuaci√≥n)

#### 3.2 Componente de Lista de Conversaciones (Continuaci√≥n)
```svelte
<!-- src/routes/dashboard/+page.svelte -->
<script lang="ts">
  import { onMount } from 'svelte';
  import { conversationsStore } from '$lib/stores/conversations.store';
  import { safeDateToISOString } from '$lib/utils/dates';
  
  let conversations: Conversation[] = [];
  let loading = true;
  let error = '';

  onMount(async () => {
    try {
      await conversationsStore.loadConversations();
      conversationsStore.subscribe(conv => {
        conversations = conv;
        loading = false;
      });
    } catch (err) {
      error = 'Error al cargar conversaciones';
      loading = false;
    }
  });

  function canSendMessage(conversation: Conversation): boolean {
    return conversation.assignedTo !== null;
  }

  function formatLastMessage(conversation: Conversation): string {
    if (!conversation.lastMessage) {
      return 'A√∫n no hay mensajes';
    }
    
    const date = safeDateToISOString(conversation.lastMessage.timestamp);
    return date ? new Date(date).toLocaleString() : 'Fecha no disponible';
  }
</script>

<div class="conversations-container">
  {#if loading}
    <div class="loading">Cargando conversaciones...</div>
  {:else if error}
    <div class="error">{error}</div>
  {:else if conversations.length === 0}
    <div class="empty-state">No hay conversaciones a√∫n</div>
  {:else}
    {#each conversations as conversation}
      <div class="conversation-item" class:unassigned={!conversation.assignedTo}>
        <div class="contact-info">
          <h3>{conversation.contact?.name || conversation.contact?.phone || 'Sin nombre'}</h3>
          <p>{formatLastMessage(conversation)}</p>
        </div>
        
        <div class="conversation-stats">
          <span class="message-count">{conversation.messageCount} mensajes</span>
          {#if conversation.unreadCount > 0}
            <span class="unread-count">{conversation.unreadCount} no le√≠dos</span>
          {/if}
        </div>
        
        {#if !conversation.assignedTo}
          <div class="warning">Sin agente asignado</div>
        {/if}
        
        <a href="/conversation/{conversation.id}" class="view-button">
          Ver conversaci√≥n
        </a>
      </div>
    {/each}
  {/if}
</div>
```

---

## üîå EVENTOS SOCKET.IO ESPEC√çFICOS

### üì° Eventos de Socket.IO (OBLIGATORIOS)
```javascript
// EVENTOS DE CONEXI√ìN
SOCKET_EVENTS = {
  // Autenticaci√≥n
  AUTHENTICATE: 'authenticate',
  AUTHENTICATED: 'authenticated',
  AUTHENTICATION_ERROR: 'authentication_error',
  
  // Sincronizaci√≥n de estado
  SYNC_STATE: 'sync-state',
  STATE_SYNCED: 'state-synced',
  SYNC_REQUIRED: 'sync-required',
  
  // Conversaciones
  JOIN_CONVERSATION: 'join-conversation',
  LEAVE_CONVERSATION: 'leave-conversation',
  CONVERSATION_JOINED: 'conversation-joined',
  CONVERSATION_LEFT: 'conversation-left',
  
  // Mensajes
  NEW_MESSAGE: 'new-message',
  MESSAGE_SENT: 'message-sent',
  MESSAGE_READ: 'message-read',
  MESSAGE_DELIVERED: 'message-delivered',
  MESSAGE_STATUS_UPDATED: 'message-status-updated',
  
  // Escritura
  USER_TYPING: 'user-typing',
  USER_TYPING_STOP: 'user-typing-stop',
  TYPING_INDICATOR: 'typing-indicator',
  
  // Presencia
  USER_PRESENCE: 'user-presence',
  PRESENCE_UPDATED: 'presence-updated',
  
  // Sistema
  SYSTEM_MESSAGE: 'system-message',
  ERROR: 'error',
  DISCONNECT: 'disconnect'
}

// EJEMPLOS DE PAYLOADS:
// Autenticaci√≥n
socket.emit('authenticate', { token: 'jwt_token_here' });

// Sincronizaci√≥n
socket.emit('sync-state', { 
  userEmail: 'admin@company.com',
  lastSync: '2025-01-15T10:00:00Z'
});

// Unirse a conversaci√≥n
socket.emit('join-conversation', { 
  conversationId: '550e8400-e29b-41d4-a716-446655440000',
  userEmail: 'admin@company.com'
});

// Nuevo mensaje
socket.emit('new-message', {
  conversationId: '550e8400-e29b-41d4-a716-446655440000',
  content: 'Hola mundo',
  type: 'text',
  replyToMessageId: null
});

// Eventos recibidos
socket.on('new-message', (message) => {
  // message = estructura completa del mensaje
});

socket.on('typing-indicator', (data) => {
  // data = { conversationId, userEmail, isTyping }
});

socket.on('presence-updated', (data) => {
  // data = { userEmail, status, lastSeen }
});
```

---

## ‚ö†Ô∏è C√ìDIGOS DE ERROR Y CASOS ESPECIALES

### üîß Configuraci√≥n de Socket.IO (OBLIGATORIA)
```javascript
// Configuraci√≥n de Socket.IO
const SOCKET_CONFIG = {
  url: 'https://utalk-backend-production.up.railway.app',
  options: {
    auth: {
      token: 'jwt_token_here'
    },
    transports: ['websocket', 'polling'],
    timeout: 30000,
    forceNew: true
  }
};
```

---

## üéØ CONFIGURACI√ìN T√âCNICA EXACTA

### üìã Variables de Entorno (OBLIGATORIAS)
```javascript
// Variables de entorno exactas
const ENV_CONFIG = {
  development: {
    API_URL: 'http://localhost:3001/api',
    SOCKET_URL: 'http://localhost:3001',
    FRONTEND_URL: 'http://localhost:5173'
  },
  production: {
    API_URL: 'https://utalk-backend-production.up.railway.app/api',
    SOCKET_URL: 'https://utalk-backend-production.up.railway.app',
    FRONTEND_URL: 'https://utalk-frontend-glt2.vercel.app'
  }
};

// Credenciales de prueba
const TEST_CREDENTIALS = {
  admin: {
    email: 'admin@company.com',
    password: '123456'
  },
  agent: {
    email: 'agent@company.com', 
    password: '123456'
  },
  viewer: {
    email: 'viewer@company.com',
    password: '123456'
  }
};
```

---

## ‚úÖ RESUMEN FINAL

### üéØ **AN√ÅLISIS COMPLETO DEL DOCUMENTO**

El documento `PLAN_FRONTEND_UTALK_COMPLETO.md` ahora contiene **TODA la informaci√≥n t√©cnica espec√≠fica** necesaria para que la IA de frontend pueda construir el m√≥dulo de chat sin ninguna complicaci√≥n:

### ‚úÖ **INFORMACI√ìN AGREGADA:**

1. **üìä ESTRUCTURAS DE DATOS EXACTAS**
   - Respuesta de login completa
   - Estructura de conversaci√≥n detallada
   - Estructura de mensaje completa
   - Respuesta paginada

2. **üåê ENDPOINTS Y API COMPLETA**
   - Todos los endpoints con ejemplos
   - Estructuras de request/response
   - Par√°metros y headers espec√≠ficos

3. **üîå EVENTOS SOCKET.IO ESPEC√çFICOS**
   - Lista completa de eventos
   - Payloads de ejemplo
   - Configuraci√≥n de Socket.IO

4. **‚ö†Ô∏è C√ìDIGOS DE ERROR Y CASOS ESPECIALES**
   - C√≥digos de error espec√≠ficos
   - Casos especiales documentados
   - Manejo de edge cases

5. **üéØ CONFIGURACI√ìN T√âCNICA EXACTA**
   - Variables de entorno
   - Credenciales de prueba
   - Headers espec√≠ficos

6. **üîß FUNCIONES UTILITARIAS OBLIGATORIAS**
   - `safeDateToISOString()` para fechas
   - Validaciones espec√≠ficas
   - Manejo de campos opcionales

### üöÄ **CON ESTA INFORMACI√ìN:**

La IA de frontend tendr√° **toda la informaci√≥n necesaria** para:
- ‚úÖ Construir componentes que se integren perfectamente con el backend
- ‚úÖ Manejar todos los casos especiales y edge cases
- ‚úÖ Implementar validaciones coherentes con el backend
- ‚úÖ Configurar Socket.IO correctamente
- ‚úÖ Manejar errores espec√≠ficos del sistema
- ‚úÖ Usar estructuras de datos exactas
- ‚úÖ Implementar autenticaci√≥n robusta
- ‚úÖ Crear un chat en tiempo real funcional

### üéØ **RESULTADO:**

El documento ahora es **100% completo** y proporciona toda la informaci√≥n t√©cnica espec√≠fica que la IA de frontend necesita para construir el m√≥dulo de chat **sin ninguna complicaci√≥n** y **sin errores de integraci√≥n**.

---

## üîå ENDPOINTS REST COMPLETOS

### üîê Endpoints de Autenticaci√≥n

#### POST /api/auth/login
```javascript
// Request
{
  "email": "admin@company.com",
  "password": "123456"
}

// Response
{
  "success": true,
  "data": {
    "user": { /* modelo de usuario completo */ },
    "tokens": {
      "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
      "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
      "expiresIn": 3600,
      "tokenType": "Bearer"
    }
  }
}
```

#### POST /api/auth/refresh
```javascript
// Request
{
  "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}

// Response
{
  "success": true,
  "data": {
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "expiresIn": 3600,
    "tokenType": "Bearer"
  }
}
```

#### POST /api/auth/logout
```javascript
// Request
// No requiere body

// Response
{
  "success": true,
  "message": "Logout exitoso",
  "data": {
    "loggedOutAt": "2025-01-15T10:30:00Z"
  }
}
```

### üí¨ Endpoints de Conversaciones

#### GET /api/conversations
```javascript
// Query Parameters
{
  "page": 1,
  "limit": 20,
  "status": "open", // "open", "pending", "resolved", "archived"
  "assignedTo": "admin@company.com",
  "search": "Juan P√©rez",
  "priority": "high", // "low", "normal", "high", "urgent"
  "tags": ["vip"],
  "startDate": "2025-01-01T00:00:00Z",
  "endDate": "2025-01-15T23:59:59Z"
}

// Response
{
  "success": true,
  "data": [/* array de conversaciones */],
  "pagination": {
    "hasMore": true,
    "nextCursor": "base64_encoded_cursor",
    "totalResults": 150,
    "limit": 20,
    "orderBy": "timestamp",
    "order": "desc"
  },
  "metadata": {
    "queryTime": "150ms",
    "appliedFilters": ["status: open", "assignedTo: admin@company.com"]
  }
}
```

#### GET /api/conversations/:id
```javascript
// Request
// GET /api/conversations/550e8400-e29b-41d4-a716-446655440000

// Response
{
  "success": true,
  "data": { /* modelo de conversaci√≥n completo */ }
}
```

#### POST /api/conversations
```javascript
// Request
{
  "customerPhone": "+521234567890",
  "customerName": "Juan P√©rez",
  "customerEmail": "juan@example.com",
  "priority": "normal",
  "tags": ["nuevo"],
  "notes": "Cliente nuevo"
}

// Response
{
  "success": true,
  "data": { /* modelo de conversaci√≥n completo */ }
}
```

#### PUT /api/conversations/:id/assign
```javascript
// Request
{
  "agentEmail": "agent@company.com",
  "notes": "Asignaci√≥n manual"
}

// Response
{
  "success": true,
  "data": {
    "conversationId": "550e8400-e29b-41d4-a716-446655440000",
    "assignedTo": {
      "id": "agent@company.com",
      "name": "Agent User",
      "email": "agent@company.com",
      "role": "agent"
    },
    "assignedAt": "2025-01-15T10:30:00Z"
  }
}
```

#### PUT /api/conversations/:id/status
```javascript
// Request
{
  "status": "resolved", // "open", "pending", "resolved", "archived"
  "notes": "Conversaci√≥n resuelta"
}

// Response
{
  "success": true,
  "data": {
    "conversationId": "550e8400-e29b-41d4-a716-446655440000",
    "status": "resolved",
    "updatedAt": "2025-01-15T10:30:00Z"
  }
}
```

#### PUT /api/conversations/:id/priority
```javascript
// Request
{
  "priority": "high", // "low", "normal", "high", "urgent"
  "notes": "Prioridad aumentada"
}

// Response
{
  "success": true,
  "data": {
    "conversationId": "550e8400-e29b-41d4-a716-446655440000",
    "priority": "high",
    "updatedAt": "2025-01-15T10:30:00Z"
  }
}
```

#### PUT /api/conversations/:id/favorite
```javascript
// Request
{
  "favorite": true
}

// Response
{
  "success": true,
  "data": {
    "conversationId": "550e8400-e29b-41d4-a716-446655440000",
    "favorite": true,
    "updatedAt": "2025-01-15T10:30:00Z"
  }
}
```

#### DELETE /api/conversations/:id
```javascript
// Request
// DELETE /api/conversations/550e8400-e29b-41d4-a716-446655440000

// Response
{
  "success": true,
  "message": "Conversaci√≥n eliminada",
  "data": {
    "conversationId": "550e8400-e29b-41d4-a716-446655440000",
    "deletedAt": "2025-01-15T10:30:00Z"
  }
}
```
