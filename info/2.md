
### 📋 Fase 4: Chat en Tiempo Real

#### 4.1 Componente de Chat
```svelte
<!-- src/routes/conversation/[id]/+page.svelte -->
<script lang="ts">
  import { onMount, onDestroy } from 'svelte';
  import { page } from '$app/stores';
  import { api } from '$lib/services/axios';
  import { socketManager } from '$lib/services/socket';
  import { validateMessage, validateFileUpload } from '$lib/utils/validation';
  import { safeDateToISOString } from '$lib/utils/dates';
  
  let messages: Message[] = [];
  let conversation: Conversation | null = null;
  let newMessage = '';
  let selectedFiles: File[] = [];
  let loading = true;
  let error = '';
  let canSend = false;

  $: conversationId = $page.params.id;

  onMount(async () => {
    await loadConversation();
    await loadMessages();
    setupSocketListeners();
    loading = false;
  });

  onDestroy(() => {
    // Limpiar listeners
    socketManager.socket?.off('new-message');
    socketManager.socket?.off('message-status-updated');
  });

  async function loadConversation() {
    try {
      const response = await api.get(`/conversations/${conversationId}`);
      conversation = response.data;
      canSend = conversation.assignedTo !== null;
    } catch (err: any) {
      error = err.response?.data?.message || 'Error al cargar conversación';
    }
  }

  async function loadMessages() {
    try {
      const response = await api.get(`/conversations/${conversationId}/messages`);
      messages = response.data;
    } catch (err: any) {
      error = 'Error al cargar mensajes';
    }
  }

  function setupSocketListeners() {
    socketManager.socket?.on('new-message', (message: Message) => {
      if (message.conversationId === conversationId) {
        messages = [...messages, message];
      }
    });

    socketManager.socket?.on('message-status-updated', (data: any) => {
      messages = messages.map(msg => 
        msg.id === data.messageId 
          ? { ...msg, status: data.status, metadata: data.metadata }
          : msg
      );
    });
  }

  function handleFileSelect(event: Event) {
    const target = event.target as HTMLInputElement;
    const files = Array.from(target.files || []);
    
    const validation = validateFileUpload(files);
    if (!validation.valid) {
      error = validation.error || 'Error en archivos';
      return;
    }
    
    selectedFiles = files;
  }

  async function sendMessage() {
    const validation = validateMessage(newMessage);
    if (!validation.valid) {
      error = validation.error || 'Error en mensaje';
      return;
    }

    if (!canSend) {
      error = 'No puedes enviar mensajes a esta conversación';
      return;
    }

    try {
      const formData = new FormData();
      formData.append('text', newMessage);
      
      selectedFiles.forEach(file => {
        formData.append('attachments', file);
      });

      const response = await api.post(`/conversations/${conversationId}/messages`, formData);
      
      // El mensaje se agregará automáticamente via socket
      newMessage = '';
      selectedFiles = [];
      error = '';
    } catch (err: any) {
      error = err.response?.data?.message || 'Error al enviar mensaje';
    }
  }

  function renderMessage(message: Message) {
    const isOwnMessage = message.sender === 'current-user';
    const date = safeDateToISOString(message.timestamp);
    
    return (
      <div class="message" class:own={isOwnMessage} class:failed={message.status === 'failed'}>
        <div class="message-content">
          <p>{message.text}</p>
          {message.metadata?.failureReason && (
            <div class="error-message">
              {message.metadata.failureReason}
              {message.metadata.retryable && (
                <button class="retry-button">Reintentar</button>
              )}
            </div>
          )}
        </div>
        <div class="message-time">
          {date ? new Date(date).toLocaleTimeString() : 'Hora no disponible'}
        </div>
      </div>
    );
  }
</script>

<div class="chat-container">
  {#if loading}
    <div class="loading">Cargando conversación...</div>
  {:else if error}
    <div class="error">{error}</div>
  {:else if !conversation}
    <div class="error">Conversación no encontrada</div>
  {:else}
    <div class="chat-header">
      <h2>{conversation.contact?.name || conversation.contact?.phone || 'Sin nombre'}</h2>
      {#if !conversation.assignedTo}
        <div class="warning">Sin agente asignado - No se pueden enviar mensajes</div>
      {/if}
    </div>

    <div class="messages-container">
      {#each messages as message}
        {renderMessage(message)}
      {/each}
    </div>

    <div class="message-input" class:disabled={!canSend}>
      <textarea 
        bind:value={newMessage}
        placeholder={canSend ? "Escribe tu mensaje..." : "Asigna un agente para enviar mensajes"}
        disabled={!canSend}
        maxlength="4096"
      />
      
      <input 
        type="file" 
        multiple 
        accept="image/*,audio/*,video/*,.pdf"
        on:change={handleFileSelect}
        disabled={!canSend}
      />
      
      <button on:click={sendMessage} disabled={!canSend || !newMessage.trim()}>
        Enviar
      </button>
    </div>
  {/if}
</div>

### 📋 Fase 5: Manejo de Errores y Estados Especiales

#### 5.1 Componente de Notificaciones
```svelte
<!-- src/lib/components/Notification.svelte -->
<script lang="ts">
  import { createEventDispatcher } from 'svelte';
  
  export let type: 'success' | 'error' | 'warning' | 'info' = 'info';
  export let message: string = '';
  export let duration: number = 5000;
  
  const dispatch = createEventDispatcher();
  
  let visible = true;
  
  if (duration > 0) {
    setTimeout(() => {
      visible = false;
      dispatch('close');
    }, duration);
  }
</script>

{#if visible}
  <div class="notification" class:notification-{type}>
    <span class="message">{message}</span>
    <button class="close-button" on:click={() => visible = false}>
      ×
    </button>
  </div>
{/if}

<style>
  .notification {
    padding: 1rem;
    border-radius: 4px;
    margin: 0.5rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  
  .notification-success { background-color: #d4edda; color: #155724; }
  .notification-error { background-color: #f8d7da; color: #721c24; }
  .notification-warning { background-color: #fff3cd; color: #856404; }
  .notification-info { background-color: #d1ecf1; color: #0c5460; }
</style>
```

#### 5.2 Store de Notificaciones
```javascript
// src/lib/stores/notifications.store.ts
import { writable } from 'svelte/store';

interface Notification {
  id: string;
  type: 'success' | 'error' | 'warning' | 'info';
  message: string;
  duration?: number;
}

const createNotificationsStore = () => {
  const { subscribe, update } = writable<Notification[]>([]);

  return {
    subscribe,
    add: (notification: Omit<Notification, 'id'>) => {
      const id = Date.now().toString();
      update(notifications => [...notifications, { ...notification, id }]);
    },
    remove: (id: string) => {
      update(notifications => notifications.filter(n => n.id !== id));
    },
    success: (message: string, duration?: number) => {
      this.add({ type: 'success', message, duration });
    },
    error: (message: string, duration?: number) => {
      this.add({ type: 'error', message, duration });
    },
    warning: (message: string, duration?: number) => {
      this.add({ type: 'warning', message, duration });
    },
    info: (message: string, duration?: number) => {
      this.add({ type: 'info', message, duration });
    }
  };
};

export const notificationsStore = createNotificationsStore();
```

### 📋 Fase 6: Testing y Validación

#### 6.1 Tests de Integración
```javascript
// src/tests/integration/auth.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { api } from '$lib/services/axios';

describe('Authentication Integration', () => {
  beforeEach(() => {
    localStorage.clear();
  });

  it('should login with valid credentials', async () => {
    const response = await api.post('/auth/login', {
      email: 'admin@company.com',
      password: '123456'
    });

    expect(response.status).toBe(200);
    expect(response.data).toHaveProperty('token');
    expect(response.data).toHaveProperty('user');
  });

  it('should handle invalid credentials', async () => {
    try {
      await api.post('/auth/login', {
        email: 'invalid@email.com',
        password: 'wrongpassword'
      });
    } catch (error: any) {
      expect(error.response.status).toBe(401);
    }
  });
});
```

#### 6.2 Tests de Validación
```javascript
// src/tests/unit/validation.test.ts
import { describe, it, expect } from 'vitest';
import { validatePhone, validateMessage, validateFileUpload } from '$lib/utils/validation';

describe('Validation Utils', () => {
  describe('validatePhone', () => {
    it('should validate correct phone numbers', () => {
      expect(validatePhone('+521234567890')).toBe(true);
      expect(validatePhone('+1234567890')).toBe(true);
    });

    it('should reject invalid phone numbers', () => {
      expect(validatePhone('1234567890')).toBe(false);
      expect(validatePhone('+123')).toBe(false);
      expect(validatePhone('abc')).toBe(false);
    });
  });

  describe('validateMessage', () => {
    it('should accept valid messages', () => {
      const result = validateMessage('Hello world');
      expect(result.valid).toBe(true);
    });

    it('should reject messages too long', () => {
      const longMessage = 'a'.repeat(4097);
      const result = validateMessage(longMessage);
      expect(result.valid).toBe(false);
      expect(result.error).toContain('4096');
    });
  });
});
```

#### 6.3 Tests de Flujo Completo
```javascript
// src/tests/e2e/complete-flow.test.ts
describe('Complete User Flow', () => {
  it('should complete login → chat → logout flow', async () => {
    // 1. Login
    const loginResponse = await api.post('/auth/login', {
      email: 'admin@company.com',
      password: '123456'
    });
    expect(loginResponse.status).toBe(200);

    // 2. Load conversations
    const conversationsResponse = await api.get('/conversations');
    expect(conversationsResponse.status).toBe(200);

    // 3. Send message (if conversation exists)
    if (conversationsResponse.data.length > 0) {
      const conversationId = conversationsResponse.data[0].id;
      const messageResponse = await api.post(`/conversations/${conversationId}/messages`, {
        text: 'Test message'
      });
      expect(messageResponse.status).toBe(201);
    }

    // 4. Logout
    const logoutResponse = await api.post('/auth/logout');
    expect(logoutResponse.status).toBe(200);
  });

  it('should handle token expiration during long operations', async () => {
    // Simular expiración de token durante upload de archivo grande
    // Verificar que se maneje TOKEN_EXPIRED_DURING_PROCESSING
  });

  it('should handle multiple users sending messages simultaneously', async () => {
    // Simular múltiples usuarios enviando mensajes al mismo tiempo
    // Verificar que no haya conflictos
  });
});
```

### 📋 Fase 7: Monitoreo y Métricas

#### 7.1 Monitoreo de Rate Limiting
```javascript
// src/lib/services/monitoring.ts
class RateLimitMonitor {
  private warnings = new Set<string>();

  handleRateLimitHeaders(response: any) {
    const remaining = response.headers['X-RateLimit-Remaining'];
    const reset = response.headers['X-RateLimit-Reset'];
    
    if (remaining < 5 && !this.warnings.has('rate-limit')) {
      this.showWarning('Estás cerca del límite de peticiones');
      this.warnings.add('rate-limit');
    }
  }

  private showWarning(message: string) {
    // Mostrar notificación al usuario
    notificationsStore.warning(message);
  }
}
```

#### 7.2 Performance Monitoring
```javascript
// src/lib/services/performance.ts
class PerformanceMonitor {
  trackApiCall(endpoint: string, duration: number) {
    console.log(`API Call to ${endpoint}: ${duration}ms`);
    
    if (duration > 5000) {
      console.warn(`Slow API call detected: ${endpoint}`);
    }
  }

  trackError(error: any) {
    console.error('API Error:', {
      status: error.response?.status,
      message: error.response?.data?.message,
      endpoint: error.config?.url,
      timestamp: new Date().toISOString()
    });
  }
}
```

---

## 🎯 CONCLUSIÓN

Este plan completo asegura que el frontend de UTalk esté **100% alineado con el backend** y maneje correctamente todos los casos especiales, validaciones y estados que el sistema requiere.

### ✅ Puntos Clave a Recordar:
1. **Usar siempre datos reales** - NO inventar información
2. **Seguir la documentación del backend** como fuente única de verdad
3. **Implementar todas las validaciones** del lado cliente
4. **Manejar todos los edge cases** documentados
5. **No duplicar lógica de negocio** en el frontend
6. **Probar con APIs reales** desde el primer día

### 🚀 Próximos Pasos:
1. Implementar la configuración base (Fase 1)
2. Desarrollar autenticación (Fase 2)
3. Crear gestión de conversaciones (Fase 3)
4. Implementar chat en tiempo real (Fase 4)
5. Agregar manejo de errores (Fase 5)
6. Realizar testing completo (Fase 6)
7. Implementar monitoreo y métricas (Fase 7)

### 📋 Checklist Final de Verificación
- [ ] **Configuración de entornos** correcta
- [ ] **Headers de autorización** implementados
- [ ] **Validaciones de emojis** funcionando
- [ ] **Rate limiting** del lado cliente
- [ ] **Eventos de escritura** con debounce
- [ ] **Logs detallados** para debugging
- [ ] **Tests de flujo completo** pasando
- [ ] **Monitoreo de performance** activo
- [ ] **Manejo de errores** específicos
- [ ] **Datos reales** en todas las pruebas

### 🎯 Resultado Esperado
Siguiendo este plan completo, el frontend de UTalk estará **100% alineado con el backend**, manejando todos los casos especiales, validaciones y estados que el sistema requiere, sin inventar datos y trabajando siempre con información real del backend.

Siguiendo este plan paso a paso, el frontend quedará preparado para integrarse perfectamente con el backend actual y futuro de UTalk.


### 📋 Fase 3: Gestión de Conversaciones (Continuación)

#### 3.2 Componente de Lista de Conversaciones (Continuación)
```svelte
<!-- src/routes/dashboard/+page.svelte -->
<script lang="ts">
  import { onMount } from 'svelte';
  import { conversationsStore } from '$lib/stores/conversations.store';
  import { safeDateToISOString } from '$lib/utils/dates';
  
  let conversations: Conversation[] = [];
  let loading = true;
  let error = '';

  onMount(async () => {
    try {
      await conversationsStore.loadConversations();
      conversationsStore.subscribe(conv => {
        conversations = conv;
        loading = false;
      });
    } catch (err) {
      error = 'Error al cargar conversaciones';
      loading = false;
    }
  });

  function canSendMessage(conversation: Conversation): boolean {
    return conversation.assignedTo !== null;
  }

  function formatLastMessage(conversation: Conversation): string {
    if (!conversation.lastMessage) {
      return 'Aún no hay mensajes';
    }
    
    const date = safeDateToISOString(conversation.lastMessage.timestamp);
    return date ? new Date(date).toLocaleString() : 'Fecha no disponible';
  }
</script>

<div class="conversations-container">
  {#if loading}
    <div class="loading">Cargando conversaciones...</div>
  {:else if error}
    <div class="error">{error}</div>
  {:else if conversations.length === 0}
    <div class="empty-state">No hay conversaciones aún</div>
  {:else}
    {#each conversations as conversation}
      <div class="conversation-item" class:unassigned={!conversation.assignedTo}>
        <div class="contact-info">
          <h3>{conversation.contact?.name || conversation.contact?.phone || 'Sin nombre'}</h3>
          <p>{formatLastMessage(conversation)}</p>
        </div>
        
        <div class="conversation-stats">
          <span class="message-count">{conversation.messageCount} mensajes</span>
          {#if conversation.unreadCount > 0}
            <span class="unread-count">{conversation.unreadCount} no leídos</span>
          {/if}
        </div>
        
        {#if !conversation.assignedTo}
          <div class="warning">Sin agente asignado</div>
        {/if}
        
        <a href="/conversation/{conversation.id}" class="view-button">
          Ver conversación
        </a>
      </div>
    {/each}
  {/if}
</div>
```

---

## 🔌 EVENTOS SOCKET.IO ESPECÍFICOS

### 📡 Eventos de Socket.IO (OBLIGATORIOS)
```javascript
// EVENTOS DE CONEXIÓN
SOCKET_EVENTS = {
  // Autenticación
  AUTHENTICATE: 'authenticate',
  AUTHENTICATED: 'authenticated',
  AUTHENTICATION_ERROR: 'authentication_error',
  
  // Sincronización de estado
  SYNC_STATE: 'sync-state',
  STATE_SYNCED: 'state-synced',
  SYNC_REQUIRED: 'sync-required',
  
  // Conversaciones
  JOIN_CONVERSATION: 'join-conversation',
  LEAVE_CONVERSATION: 'leave-conversation',
  CONVERSATION_JOINED: 'conversation-joined',
  CONVERSATION_LEFT: 'conversation-left',
  
  // Mensajes
  NEW_MESSAGE: 'new-message',
  MESSAGE_SENT: 'message-sent',
  MESSAGE_READ: 'message-read',
  MESSAGE_DELIVERED: 'message-delivered',
  MESSAGE_STATUS_UPDATED: 'message-status-updated',
  
  // Escritura
  USER_TYPING: 'user-typing',
  USER_TYPING_STOP: 'user-typing-stop',
  TYPING_INDICATOR: 'typing-indicator',
  
  // Presencia
  USER_PRESENCE: 'user-presence',
  PRESENCE_UPDATED: 'presence-updated',
  
  // Sistema
  SYSTEM_MESSAGE: 'system-message',
  ERROR: 'error',
  DISCONNECT: 'disconnect'
}

// EJEMPLOS DE PAYLOADS:
// Autenticación
socket.emit('authenticate', { token: 'jwt_token_here' });

// Sincronización
socket.emit('sync-state', { 
  userEmail: 'admin@company.com',
  lastSync: '2025-01-15T10:00:00Z'
});

// Unirse a conversación
socket.emit('join-conversation', { 
  conversationId: '550e8400-e29b-41d4-a716-446655440000',
  userEmail: 'admin@company.com'
});

// Nuevo mensaje
socket.emit('new-message', {
  conversationId: '550e8400-e29b-41d4-a716-446655440000',
  content: 'Hola mundo',
  type: 'text',
  replyToMessageId: null
});

// Eventos recibidos
socket.on('new-message', (message) => {
  // message = estructura completa del mensaje
});

socket.on('typing-indicator', (data) => {
  // data = { conversationId, userEmail, isTyping }
});

socket.on('presence-updated', (data) => {
  // data = { userEmail, status, lastSeen }
});
```

---

## ⚠️ CÓDIGOS DE ERROR Y CASOS ESPECIALES

### 🔧 Configuración de Socket.IO (OBLIGATORIA)
```javascript
// Configuración de Socket.IO
const SOCKET_CONFIG = {
  url: 'https://utalk-backend-production.up.railway.app',
  options: {
    auth: {
      token: 'jwt_token_here'
    },
    transports: ['websocket', 'polling'],
    timeout: 30000,
    forceNew: true
  }
};
```

---

## 🎯 CONFIGURACIÓN TÉCNICA EXACTA

### 📋 Variables de Entorno (OBLIGATORIAS)
```javascript
// Variables de entorno exactas
const ENV_CONFIG = {
  development: {
    API_URL: 'http://localhost:3001/api',
    SOCKET_URL: 'http://localhost:3001',
    FRONTEND_URL: 'http://localhost:5173'
  },
  production: {
    API_URL: 'https://utalk-backend-production.up.railway.app/api',
    SOCKET_URL: 'https://utalk-backend-production.up.railway.app',
    FRONTEND_URL: 'https://utalk-frontend-glt2.vercel.app'
  }
};

// Credenciales de prueba
const TEST_CREDENTIALS = {
  admin: {
    email: 'admin@company.com',
    password: '123456'
  },
  agent: {
    email: 'agent@company.com', 
    password: '123456'
  },
  viewer: {
    email: 'viewer@company.com',
    password: '123456'
  }
};
```

---

## ✅ RESUMEN FINAL

### 🎯 **ANÁLISIS COMPLETO DEL DOCUMENTO**

El documento `PLAN_FRONTEND_UTALK_COMPLETO.md` ahora contiene **TODA la información técnica específica** necesaria para que la IA de frontend pueda construir el módulo de chat sin ninguna complicación:

### ✅ **INFORMACIÓN AGREGADA:**

1. **📊 ESTRUCTURAS DE DATOS EXACTAS**
   - Respuesta de login completa
   - Estructura de conversación detallada
   - Estructura de mensaje completa
   - Respuesta paginada

2. **🌐 ENDPOINTS Y API COMPLETA**
   - Todos los endpoints con ejemplos
   - Estructuras de request/response
   - Parámetros y headers específicos

3. **🔌 EVENTOS SOCKET.IO ESPECÍFICOS**
   - Lista completa de eventos
   - Payloads de ejemplo
   - Configuración de Socket.IO

4. **⚠️ CÓDIGOS DE ERROR Y CASOS ESPECIALES**
   - Códigos de error específicos
   - Casos especiales documentados
   - Manejo de edge cases

5. **🎯 CONFIGURACIÓN TÉCNICA EXACTA**
   - Variables de entorno
   - Credenciales de prueba
   - Headers específicos

6. **🔧 FUNCIONES UTILITARIAS OBLIGATORIAS**
   - `safeDateToISOString()` para fechas
   - Validaciones específicas
   - Manejo de campos opcionales

### 🚀 **CON ESTA INFORMACIÓN:**

La IA de frontend tendrá **toda la información necesaria** para:
- ✅ Construir componentes que se integren perfectamente con el backend
- ✅ Manejar todos los casos especiales y edge cases
- ✅ Implementar validaciones coherentes con el backend
- ✅ Configurar Socket.IO correctamente
- ✅ Manejar errores específicos del sistema
- ✅ Usar estructuras de datos exactas
- ✅ Implementar autenticación robusta
- ✅ Crear un chat en tiempo real funcional

### 🎯 **RESULTADO:**

El documento ahora es **100% completo** y proporciona toda la información técnica específica que la IA de frontend necesita para construir el módulo de chat **sin ninguna complicación** y **sin errores de integración**.

---

## 🔌 ENDPOINTS REST COMPLETOS

### 🔐 Endpoints de Autenticación

#### POST /api/auth/login
```javascript
// Request
{
  "email": "admin@company.com",
  "password": "123456"
}

// Response
{
  "success": true,
  "data": {
    "user": { /* modelo de usuario completo */ },
    "tokens": {
      "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
      "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
      "expiresIn": 3600,
      "tokenType": "Bearer"
    }
  }
}
```

#### POST /api/auth/refresh
```javascript
// Request
{
  "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}

// Response
{
  "success": true,
  "data": {
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "expiresIn": 3600,
    "tokenType": "Bearer"
  }
}
```

#### POST /api/auth/logout
```javascript
// Request
// No requiere body

// Response
{
  "success": true,
  "message": "Logout exitoso",
  "data": {
    "loggedOutAt": "2025-01-15T10:30:00Z"
  }
}
```

### 💬 Endpoints de Conversaciones

#### GET /api/conversations
```javascript
// Query Parameters
{
  "page": 1,
  "limit": 20,
  "status": "open", // "open", "pending", "resolved", "archived"
  "assignedTo": "admin@company.com",
  "search": "Juan Pérez",
  "priority": "high", // "low", "normal", "high", "urgent"
  "tags": ["vip"],
  "startDate": "2025-01-01T00:00:00Z",
  "endDate": "2025-01-15T23:59:59Z"
}

// Response
{
  "success": true,
  "data": [/* array de conversaciones */],
  "pagination": {
    "hasMore": true,
    "nextCursor": "base64_encoded_cursor",
    "totalResults": 150,
    "limit": 20,
    "orderBy": "timestamp",
    "order": "desc"
  },
  "metadata": {
    "queryTime": "150ms",
    "appliedFilters": ["status: open", "assignedTo: admin@company.com"]
  }
}
```

#### GET /api/conversations/:id
```javascript
// Request
// GET /api/conversations/550e8400-e29b-41d4-a716-446655440000

// Response
{
  "success": true,
  "data": { /* modelo de conversación completo */ }
}
```

#### POST /api/conversations
```javascript
// Request
{
  "customerPhone": "+521234567890",
  "customerName": "Juan Pérez",
  "customerEmail": "juan@example.com",
  "priority": "normal",
  "tags": ["nuevo"],
  "notes": "Cliente nuevo"
}

// Response
{
  "success": true,
  "data": { /* modelo de conversación completo */ }
}
```

#### PUT /api/conversations/:id/assign
```javascript
// Request
{
  "agentEmail": "agent@company.com",
  "notes": "Asignación manual"
}

// Response
{
  "success": true,
  "data": {
    "conversationId": "550e8400-e29b-41d4-a716-446655440000",
    "assignedTo": {
      "id": "agent@company.com",
      "name": "Agent User",
      "email": "agent@company.com",
      "role": "agent"
    },
    "assignedAt": "2025-01-15T10:30:00Z"
  }
}
```

#### PUT /api/conversations/:id/status
```javascript
// Request
{
  "status": "resolved", // "open", "pending", "resolved", "archived"
  "notes": "Conversación resuelta"
}

// Response
{
  "success": true,
  "data": {
    "conversationId": "550e8400-e29b-41d4-a716-446655440000",
    "status": "resolved",
    "updatedAt": "2025-01-15T10:30:00Z"
  }
}
```

#### PUT /api/conversations/:id/priority
```javascript
// Request
{
  "priority": "high", // "low", "normal", "high", "urgent"
  "notes": "Prioridad aumentada"
}

// Response
{
  "success": true,
  "data": {
    "conversationId": "550e8400-e29b-41d4-a716-446655440000",
    "priority": "high",
    "updatedAt": "2025-01-15T10:30:00Z"
  }
}
```

#### PUT /api/conversations/:id/favorite
```javascript
// Request
{
  "favorite": true
}

// Response
{
  "success": true,
  "data": {
    "conversationId": "550e8400-e29b-41d4-a716-446655440000",
    "favorite": true,
    "updatedAt": "2025-01-15T10:30:00Z"
  }
}
```

#### DELETE /api/conversations/:id
```javascript
// Request
// DELETE /api/conversations/550e8400-e29b-41d4-a716-446655440000

// Response
{
  "success": true,
  "message": "Conversación eliminada",
  "data": {
    "conversationId": "550e8400-e29b-41d4-a716-446655440000",
    "deletedAt": "2025-01-15T10:30:00Z"
  }
}
```
