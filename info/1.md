# üöÄ PLAN COMPLETO DE DESARROLLO FRONTEND - UTALK

## üéØ **CONTEXTO CR√çTICO PARA LA IA DE FRONTEND**

### üìã **¬øQU√â VAS A CONSTRUIR?**
Un **sistema de chat empresarial completo** que incluye:
- **Autenticaci√≥n robusta** con JWT y refresh tokens
- **Gesti√≥n de conversaciones** con asignaci√≥n de agentes
- **Chat en tiempo real** con Socket.IO
- **Sistema de mensajes** con archivos adjuntos
- **Gesti√≥n de contactos** y perfiles
- **Sistema de roles** (admin, agent, viewer)
- **Notificaciones** y estados en tiempo real

### üîß **¬øC√ìMO LO VAS A CONSTRUIR?**
- **React/Svelte/Vue** con TypeScript
- **Socket.IO Client** para tiempo real
- **Axios/Fetch** para APIs REST
- **Estado global** (Redux/Zustand/Svelte stores)
- **Validaciones** del lado cliente
- **Manejo de errores** espec√≠fico
- **UI responsive** y accesible

### ‚ö†Ô∏è **¬øQU√â DEBES TOMAR EN CUENTA?**
- **NUNCA inventar datos** - Usar solo informaci√≥n real del backend
- **Seguir exactamente** las estructuras JSON del backend
- **Manejar TODOS los casos especiales** documentados
- **Validar antes de enviar** - No confiar en validaciones del servidor
- **Manejar reconexiones** autom√°ticas de Socket.IO
- **Mostrar estados de carga** y errores apropiados
- **Implementar rate limiting** del lado cliente
- **Manejar tokens expirados** autom√°ticamente

### üö® **REGLAS FUNDAMENTALES:**
1. **Documentaci√≥n = Fuente √∫nica de verdad**
2. **Datos reales siempre** - NO mocks
3. **Validaciones coherentes** con el backend
4. **Manejo robusto de errores**
5. **UX consistente** en todos los estados
6. **Performance optimizada** para tiempo real

---

## üìã √çNDICE
1. [Importancia de la Documentaci√≥n de Backend](#importancia-de-la-documentaci√≥n-de-backend)
2. [Separaci√≥n de Responsabilidades](#separaci√≥n-de-responsabilidades)
3. [Manejo de Datos: Formatos, Fechas e IDs](#manejo-de-datos-formatos-fechas-e-ids)
4. [Validaciones y Reglas de Negocio](#validaciones-y-reglas-de-negocio)
5. [Casos Especiales que la UI Debe Manejar](#casos-especiales-que-la-ui-debe-manejar)
6. [Funcionalidades de Backend Pendientes](#funcionalidades-de-backend-pendientes)
7. [Checklist Esencial para el Frontend](#checklist-esencial-para-el-frontend)
8. [Uso de Datos Reales](#uso-de-datos-reales)
9. [Implementaci√≥n Paso a Paso](#implementaci√≥n-paso-a-paso)
10. [Monitoreo y M√©tricas](#monitoreo-y-m√©tricas)
11. [üîß INFORMACI√ìN T√âCNICA ESPEC√çFICA DEL BACKEND](#informaci√≥n-t√©cnica-espec√≠fica-del-backend)
12. [üìä ESTRUCTURAS DE DATOS EXACTAS](#estructuras-de-datos-exactas)
13. [üåê ENDPOINTS Y API COMPLETA](#endpoints-y-api-completa)
14. [üîå EVENTOS SOCKET.IO ESPEC√çFICOS](#eventos-socketio-espec√≠ficos)
15. [‚ö†Ô∏è C√ìDIGOS DE ERROR Y CASOS ESPECIALES](#c√≥digos-de-error-y-casos-especiales)
16. [üéØ CONFIGURACI√ìN T√âCNICA EXACTA](#configuraci√≥n-t√©cnica-exacta)
17. [üìã MODELOS JSON COMPLETOS](#modelos-json-completos)
18. [üîå ENDPOINTS REST COMPLETOS](#endpoints-rest-completos)
19. [üé® REGLAS Y METADATOS ESPEC√çFICOS](#reglas-y-metadatos-espec√≠ficos)
20. [‚ö†Ô∏è CASOS L√çMITE Y ERRORES ESPEC√çFICOS](#casos-l√≠mite-y-errores-espec√≠ficos)
21. [üîÑ REGLAS DE NEGOCIO DETALLADAS](#reglas-de-negocio-detalladas)
22. [üì± CASOS ESPEC√çFICOS DE UI](#casos-espec√≠ficos-de-ui)
23. [üîß CONFIGURACI√ìN Y ENTORNOS COMPLETOS](#configuraci√≥n-y-entornos-completos)
24. [‚ùì PREGUNTAS ABIERTAS RESUELTAS](#preguntas-abiertas-resueltas)

---

## üéØ IMPORTANCIA DE LA DOCUMENTACI√ìN DE BACKEND

### ‚úÖ Principio Fundamental
- **Documentaci√≥n exhaustiva** del backend es la **fuente √∫nica de verdad**
- Contiene todos los *edge cases*, transformaciones impl√≠citas, *side effects* y comportamientos especiales
- **ANTES de construir cualquier funcionalidad**, analizar profundamente el documento
- Informaci√≥n actualizada al 2025-08-02 con *best practices* y correcciones recientes
- **ESTRUCTURAS DE DATOS EXACTAS** del backend para evitar incompatibilidades

### üö® Consecuencias de No Seguir la Documentaci√≥n
- Incompatibilidades durante pruebas de integraci√≥n
- Errores de comunicaci√≥n entre frontend y backend
- Funcionalidades que no funcionan en producci√≥n
- **Errores de formato de datos** que causan crashes
- **Incompatibilidad de tipos** entre frontend y backend

---

## üîÑ SEPARACI√ìN DE RESPONSABILIDADES

### üìã Regla de Oro
**L√≥gica de negocio compleja = Backend**
**Presentaci√≥n e interacci√≥n = Frontend**

### üéØ Responsabilidades Espec√≠ficas del Backend
- **C√°lculo de contadores** (unreadCount, messageCount)
- **Actualizaci√≥n autom√°tica** de lastMessage y lastMessageAt
- **Emisiones Socket.IO** en tiempo real
- **Validaciones complejas** de permisos y roles
- **Rate limiting** y control de acceso
- **Procesamiento de archivos** y metadatos
- **Gesti√≥n de estados** de mensajes (sent, delivered, read, failed)

### ‚ùå Lo que NO debe hacer el Frontend
- Duplicar l√≥gica ya implementada en el backend
- Intentar replicar actualizaciones autom√°ticas del servidor
- Calcular campos que el backend ya calcula din√°micamente

### ‚úÖ Ejemplos de L√≥gica que Reside en Backend
Cuando se crea un mensaje, el backend autom√°ticamente:
- Marca el √∫ltimo mensaje de la conversaci√≥n
- Incrementa contadores
- Env√≠a emisiones en tiempo real via Socket.IO
- Calcula campos como `isOnline`, `lastSeen`, contadores de mensajes no le√≠dos
- **Actualiza `lastMessageAt`** en la conversaci√≥n
- **Incrementa `messageCount`** autom√°ticamente
- **Emite evento `new-message`** a todos los participantes
- **Procesa archivos adjuntos** y genera URLs
- **Valida permisos** antes de guardar
- **Aplica rate limiting** por usuario

### üéØ Responsabilidad del Frontend
- Construir la UI
- Consumir las APIs
- Reaccionar a datos y eventos del backend
- **NO suplantar l√≥gica de procesamiento**
- **Escuchar eventos Socket.IO** y actualizar UI
- **Mostrar estados en tiempo real** (typing, online, etc.)
- **Manejar reconexiones** autom√°ticamente
- **Validar datos de entrada** antes de enviar

---

## üìä MANEJO DE DATOS: FORMATOS, FECHAS E IDs

### üìÖ M√∫ltiples Formatos de Fecha
El backend puede responder con **6 formatos distintos**:

1. **ISO string** - `"2025-01-15T10:30:00Z"`
2. **Objetos Firestore** - `{_seconds: 1705312200, _nanoseconds: 0}`
3. **Timestamp num√©rico** - `1705312200000`
4. **null** - `null`
5. **undefined** - `undefined`
6. **Otros formatos espec√≠ficos**

### üîß Funci√≥n Utilitaria para Fechas (OBLIGATORIA)
```javascript
const safeDateToISOString = (date) => {
  if (!date) return null;
  
  if (typeof date === 'string') {
    return date;
  }
  
  if (typeof date === 'number') {
    return new Date(date).toISOString();
  }
  
  if (date._seconds) {
    // Firestore timestamp
    return new Date(date._seconds * 1000).toISOString();
  }
  
  if (date instanceof Date) {
    return date.toISOString();
  }
  
  return null;
}
```

### üîê Headers de Autorizaci√≥n Espec√≠ficos
- **Login inicial**: Debe incluir `Authorization: Bearer ` (vac√≠o)
- **Todas las peticiones**: Requieren token JWT v√°lido
- **Interceptor global**: Adjuntar autom√°ticamente el header
- **Token vac√≠o**: Usar cadena vac√≠a si a√∫n no hay token

### üîß Configuraci√≥n de Headers (OBLIGATORIA)
```javascript
// Headers est√°ndar para todas las peticiones
const AUTH_HEADERS = {
  'Authorization': 'Bearer jwt_token_here',
  'Content-Type': 'application/json'
};

// Headers para multipart (archivos)
const MULTIPART_HEADERS = {
  'Authorization': 'Bearer jwt_token_here',
  'Content-Type': 'multipart/form-data'
};

// Headers de rate limiting
const RATE_LIMIT_HEADERS = {
  'X-RateLimit-Limit': '100',
  'X-RateLimit-Remaining': '95', 
  'X-RateLimit-Reset': '1642234567'
};
```

### üîß Soluci√≥n Recomendada
```javascript
// Usar funci√≥n utilitaria para estandarizar fechas
const safeDateToISOString = (date) => {
  if (!date) return null;
  
  if (typeof date === 'string') {
    return date;
  }
  
  if (typeof date === 'number') {
    return new Date(date).toISOString();
  }
  
  if (date._seconds) {
    // Firestore timestamp
    return new Date(date._seconds * 1000).toISOString();
  }
  
  if (date instanceof Date) {
    return date.toISOString();
  }
  
  return null;
}
```

### üÜî Diferentes Formatos de IDs
- **UUID v4** - Para conversaciones
- **IDs de Firestore** - Cadenas cortas
- **N√∫meros de tel√©fono** - Como IDs de contacto
- **IDs propios** - Seg√∫n contexto

### üîß Validaci√≥n de IDs (OBLIGATORIA)
```javascript
// Validar UUID antes de enviar
const isValidUUID = (uuid) => {
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  return uuidRegex.test(uuid);
}

// Validar tel√©fono internacional
const isValidPhone = (phone) => {
  const phoneRegex = /^\+[1-9]\d{1,14}$/;
  return phoneRegex.test(phone);
}
```

### ‚úÖ Validaci√≥n de IDs
```javascript
// Validar UUID antes de enviar
const isValidUUID = (uuid) => {
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  return uuidRegex.test(uuid);
}
```

### ‚ö†Ô∏è Campos Opcionales o Condicionales
**NUNCA asumir que un campo siempre estar√° presente**

#### Ejemplos de Campos Condicionales:
- `contact` - Solo si existe contacto relacionado
- `lastMessage` - Solo si hay mensajes en la conversaci√≥n
- `assignedTo` - Puede ser `null` si no hay agente asignado
- `metadata` - Puede ser `undefined` en mensajes simples
- `readBy` - Solo presente si el mensaje ha sido le√≠do
- `mediaUrl` - Solo presente en mensajes con archivos

#### üõ°Ô∏è Manejo Seguro:
```javascript
// ‚úÖ Correcto
const contactName = conversation.contact?.name || "Sin nombre";
const lastMessage = conversation.lastMessage || "A√∫n no hay mensajes";
const assignedAgent = conversation.assignedTo?.name || "Sin asignar";
const messageContent = message.content || message.mediaUrl || "[Sin contenido]";

// ‚ùå Incorrecto
const contactName = conversation.contact.name; // Puede fallar
const lastMessage = conversation.lastMessage.content; // Puede fallar
```

---

## ‚úÖ VALIDACIONES Y REGLAS DE NEGOCIO

### üìù Validaciones de Entrada (Frontend)
Implementar las **mismas reglas** que el backend:

#### üìè L√≠mites de Texto
- **Mensajes**: M√°ximo 4096 caracteres
- **Nombres**: Seg√∫n esquemas Joi del backend
- **Descripciones**: L√≠mites espec√≠ficos por campo

### üîß Reglas de Validaci√≥n Espec√≠ficas (OBLIGATORIAS)
```javascript
const VALIDATION_RULES = {
  // Mensajes
  message: {
    content: {
      maxLength: 4096,
      required: true
    },
    type: {
      allowed: ['text', 'image', 'audio', 'video', 'document'],
      default: 'text'
    },
    replyToMessageId: {
      format: 'uuid',
      optional: true
    }
  },
  
  // Conversaciones
  conversation: {
    customerPhone: {
      pattern: /^\+[1-9]\d{1,14}$/,
      required: true
    },
    priority: {
      allowed: ['low', 'normal', 'high', 'urgent'],
      default: 'normal'
    },
    tags: {
      maxItems: 10,
      optional: true
    }
  },
  
  // Archivos
  file: {
    maxSize: 100 * 1024 * 1024, // 100MB
    maxFiles: 10,
    allowedTypes: [
      'image/jpeg', 'image/png', 'image/webp',
      'audio/mp3', 'audio/ogg', 'audio/wav',
      'video/mp4', 'video/webm',
      'application/pdf'
    ],
    blockedExtensions: ['.exe', '.js', '.bat', '.cmd']
  },
  
  // Tel√©fonos
  phone: {
    pattern: /^\+[1-9]\d{1,14}$/,
    examples: ['+521234567890', '+1234567890']
  }
};
```

#### üé® Consideraciones Especiales con Emojis
- **Emojis**: Cuentan como m√∫ltiples bytes en validaci√≥n de longitud
- **Validaci√≥n en tiempo real**: Mostrar contador de caracteres restantes
- **L√≠mite real**: 4096 bytes, no caracteres
- **Contador din√°mico**: Actualizar mientras el usuario escribe

#### üìû Validaci√≥n de Tel√©fonos
```javascript
// Formato internacional requerido
const phoneRegex = /^\+[1-9]\d{1,14}$/;
// Ejemplo v√°lido: +521234567890

// Funci√≥n de validaci√≥n completa
const validatePhone = (phone) => {
  const phoneRegex = /^\+[1-9]\d{1,14}$/;
  return phoneRegex.test(phone);
}

// Normalizaci√≥n de tel√©fono
const normalizePhone = (phone) => {
  // Asegurar formato internacional
  if (phone.startsWith('+')) return phone;
  if (phone.startsWith('52')) return `+${phone}`;
  return `+52${phone}`;
}
```

#### üìé Validaci√≥n de Archivos
- **M√°ximo**: 10 archivos por mensaje
- **Tama√±o m√°ximo**: 100MB por archivo
- **Tipos permitidos**: JPEG, PNG, WebP, MP3, OGG, WAV, MP4, WEBM, PDF
- **Tipos bloqueados**: .exe, .js, etc.

```javascript
// Funci√≥n de validaci√≥n de archivos completa
const validateFileUpload = (files) => {
  const allowedTypes = [
    'image/jpeg', 'image/png', 'image/webp',
    'audio/mp3', 'audio/ogg', 'audio/wav',
    'video/mp4', 'video/webm',
    'application/pdf'
  ];
  
  const blockedExtensions = ['.exe', '.js', '.bat', '.cmd'];
  
  for (const file of files) {
    if (file.size > 100 * 1024 * 1024) {
      return { valid: false, error: `Archivo ${file.name} excede 100MB` };
    }
    
    if (!allowedTypes.includes(file.type)) {
      return { valid: false, error: `Tipo de archivo no permitido: ${file.type}` };
    }
    
    const extension = file.name.toLowerCase().substring(file.name.lastIndexOf('.'));
    if (blockedExtensions.includes(extension)) {
      return { valid: false, error: `Extensi√≥n bloqueada: ${extension}` };
    }
  }
  
  if (files.length > 10) {
    return { valid: false, error: "M√°ximo 10 archivos por mensaje" };
  }
  
  return { valid: true };
}
```

### üîê Reglas de Autorizaci√≥n
#### üë• Roles de Usuario
- **viewer**: No puede enviar mensajes ni ver conversaciones
- **agent**: Puede enviar mensajes y ver conversaciones asignadas
- **admin**: Acceso completo

#### üö´ Restricciones de Negocio
- **Conversaci√≥n no asignada**: No se pueden enviar mensajes
- **Reasignaci√≥n duplicada**: No asignar al mismo agente
- **Rate limiting**: L√≠mites por usuario e IP

### üîß C√≥digos de Error Espec√≠ficos (OBLIGATORIOS)
```javascript
const ERROR_CODES = {
  // Autenticaci√≥n
  'NOT_AUTHENTICATED': 'Usuario no autenticado',
  'TOKEN_EXPIRED': 'Token expirado',
  'TOKEN_EXPIRED_DURING_PROCESSING': 'Token expirado durante el procesamiento',
  'INVALID_TOKEN': 'Token inv√°lido',
  'USER_NOT_FOUND': 'Usuario no encontrado',
  'USER_INACTIVE': 'Usuario inactivo',
  
  // Permisos
  'INSUFFICIENT_ROLE': 'Rol insuficiente',
  'USER_NOT_AUTHORIZED': 'Usuario no autorizado',
  'CONVERSATION_NOT_FOUND': 'Conversaci√≥n no encontrada',
  'MESSAGE_NOT_FOUND': 'Mensaje no encontrado',
  
  // Validaci√≥n
  'VALIDATION_ERROR': 'Error de validaci√≥n',
  'MISSING_CONTENT': 'Contenido faltante',
  'INVALID_PHONE': 'N√∫mero de tel√©fono inv√°lido',
  'FILE_TOO_LARGE': 'Archivo demasiado grande',
  'INVALID_FILE_TYPE': 'Tipo de archivo inv√°lido',
  
  // Rate Limiting
  'RATE_LIMIT_EXCEEDED': 'L√≠mite de peticiones excedido',
  'TOO_MANY_REQUESTS': 'Demasiadas peticiones',
  
  // Negocio
  'CONVERSATION_NOT_ASSIGNED': 'Conversaci√≥n no asignada',
  'AGENT_NOT_FOUND': 'Agente no encontrado',
  'DUPLICATE_ASSIGNMENT': 'Asignaci√≥n duplicada',
  
  // Sistema
  'INTERNAL_SERVER_ERROR': 'Error interno del servidor',
  'SERVICE_UNAVAILABLE': 'Servicio no disponible',
  'DATABASE_ERROR': 'Error de base de datos'
};
```

### üîß Implementaci√≥n de Validaciones
```javascript
// Ejemplo: Validaci√≥n de mensaje con emojis
const validateMessage = (text) => {
  // Contar bytes reales, no caracteres
  const byteLength = new TextEncoder().encode(text).length;
  
  if (byteLength > 4096) {
    return { 
      valid: false, 
      error: `Mensaje demasiado largo (${byteLength}/4096 bytes)` 
    };
  }
  return { valid: true, remaining: 4096 - byteLength };
}

// Validaci√≥n de tel√©fono con regex espec√≠fica
const validatePhone = (phone) => {
  const phoneRegex = /^\+[1-9]\d{1,14}$/;
  return phoneRegex.test(phone);
}

// Validaci√≥n de archivos con tipos espec√≠ficos
const validateFileUpload = (files) => {
  const allowedTypes = [
    'image/jpeg', 'image/png', 'image/webp',
    'audio/mp3', 'audio/ogg', 'audio/wav',
    'video/mp4', 'video/webm',
    'application/pdf'
  ];
  
  const blockedExtensions = ['.exe', '.js', '.bat', '.cmd'];
  
  for (const file of files) {
    if (file.size > 100 * 1024 * 1024) {
      return { valid: false, error: `Archivo ${file.name} excede 100MB` };
    }
    
    if (!allowedTypes.includes(file.type)) {
      return { valid: false, error: `Tipo de archivo no permitido: ${file.type}` };
    }
    
    const extension = file.name.toLowerCase().substring(file.name.lastIndexOf('.'));
    if (blockedExtensions.includes(extension)) {
      return { valid: false, error: `Extensi√≥n bloqueada: ${extension}` };
    }
  }
  
  if (files.length > 10) {
    return { valid: false, error: "M√°ximo 10 archivos por mensaje" };
  }
  
  return { valid: true };
}

// Validaci√≥n de permisos por rol
const validatePermissions = (userRole, action, resource) => {
  const permissions = {
    viewer: ['read_conversations'],
    agent: ['read_conversations', 'write_messages', 'assign_conversations'],
    admin: ['read_conversations', 'write_messages', 'assign_conversations', 'manage_users', 'view_stats']
  };
  
  return permissions[userRole]?.includes(action) || false;
}
```

---

## ‚ö†Ô∏è CASOS ESPECIALES QUE LA UI DEBE MANEJAR

### 1Ô∏è‚É£ Conversaci√≥n Sin Agente Asignado
```javascript
// Estado: assignedTo: null
// Comportamiento: Backend rechaza mensajes (error 403)
// UI debe: Deshabilitar entrada de mensaje
```

#### üéØ Implementaci√≥n:
```javascript
const canSendMessage = (conversation) => {
  return conversation.assignedTo !== null;
}

// En la UI
if (!canSendMessage(conversation)) {
  showWarning("Asigna un agente antes de responder");
  disableMessageInput();
}
```

### 2Ô∏è‚É£ Mensaje con Env√≠o Fallido
```javascript
// Estado: status: "failed"
// Metadata: { failureReason, twilioError, retryable }
```

#### üéØ Implementaci√≥n:
```javascript
const renderMessageStatus = (message) => {
  if (message.status === "failed") {
    return (
      <div className="failed-message">
        <IconWarning />
        <span>{message.metadata.failureReason}</span>
        {message.metadata.retryable && <RetryButton />}
      </div>
    );
  }
}
```

### 3Ô∏è‚É£ Token Expirado Durante Procesamiento
```javascript
// Error: 401 con c√≥digo TOKEN_EXPIRED_DURING_PROCESSING
// Acci√≥n: Refresh token autom√°tico + reintentar operaci√≥n
```

#### üéØ Implementaci√≥n:
```javascript
// Interceptor de Axios
axios.interceptors.response.use(
  (response) => response,
  async (error) => {
    if (error.response?.status === 401 && 
        error.response?.data?.code === 'TOKEN_EXPIRED_DURING_PROCESSING') {
      await refreshToken();
      return axios.request(error.config); // Reintentar
    }
    return Promise.reject(error);
  }
);
```

### 4Ô∏è‚É£ Rate Limiting
```javascript
// Headers: X-RateLimit-Remaining, X-RateLimit-Reset
// Error: 429 con retryAfter
```

#### üéØ Implementaci√≥n:
```javascript
const handleRateLimit = (response) => {
  const remaining = response.headers['X-RateLimit-Remaining'];
  const reset = response.headers['X-RateLimit-Reset'];
  
  if (remaining < 5) {
    showWarning("Est√°s cerca del l√≠mite de peticiones");
  }
}

const handle429Error = (error) => {
  const retryAfter = error.response?.data?.retryAfter;
  showError(`Has excedido el l√≠mite. Intenta de nuevo en ${retryAfter}`);
}
```

### 5Ô∏è‚É£ Reconexi√≥n de WebSocket
```javascript
// Evento: socket.on('disconnect')
// Acci√≥n: Reconexi√≥n con exponential backoff
```

#### üéØ Implementaci√≥n:
```javascript
class SocketManager {
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  
  reconnect() {
    const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);
    
    setTimeout(() => {
      this.connect();
      this.emit('sync-state'); // Sincronizar estado
    }, delay);
  }
}
```

### 6Ô∏è‚É£ Eventos de Escritura ("User is Typing")
```javascript
// Rate limit: M√°ximo 2 eventos por segundo por usuario
// Debounce: 500ms para evitar sobrecarga
```

#### üéØ Implementaci√≥n:
```javascript
class TypingManager {
  private lastTypingEvent = 0;
  private typingDebounce = 500;
  
  sendTypingEvent(conversationId: string) {
    const now = Date.now();
    if (now - this.lastTypingEvent > this.typingDebounce) {
      socket.emit('user-typing', { conversationId });
      this.lastTypingEvent = now;
    }
  }
}
```

### üîß Casos Especiales Espec√≠ficos (OBLIGATORIOS)
```javascript
const SPECIAL_CASES = {
  // Conversaci√≥n sin agente asignado
  unassignedConversation: {
    condition: 'conversation.assignedTo === null',
    behavior: 'No se pueden enviar mensajes',
    errorCode: 'CONVERSATION_NOT_ASSIGNED',
    uiAction: 'Deshabilitar input de mensaje, mostrar warning'
  },
  
  // Mensaje fallido
  failedMessage: {
    condition: 'message.status === "failed"',
    metadata: {
      failureReason: 'Error de Twilio',
      retryable: true,
      twilioError: 'Invalid phone number'
    },
    uiAction: 'Mostrar mensaje en rojo, bot√≥n de reintentar'
  },
  
  // Token expirado durante procesamiento
  tokenExpiredDuringProcessing: {
    condition: 'error.code === "TOKEN_EXPIRED_DURING_PROCESSING"',
    action: 'Refresh token autom√°tico + reintentar operaci√≥n',
    uiAction: 'Mostrar loading, no mostrar error al usuario'
  },
  
  // Rate limiting
  rateLimitExceeded: {
    condition: 'error.code === "RATE_LIMIT_EXCEEDED"',
    headers: {
      'X-RateLimit-Remaining': '0',
      'X-RateLimit-Reset': '1642234567'
    },
    uiAction: 'Mostrar error con tiempo de espera'
  },
  
  // Reconexi√≥n de Socket
  socketReconnection: {
    trigger: 'socket.on("disconnect")',
    action: 'Reconexi√≥n con exponential backoff',
    backoff: [1000, 2000, 5000, 10000, 30000],
    maxAttempts: 5,
    uiAction: 'Mostrar indicador de reconexi√≥n'
  }
};
```

### 2Ô∏è‚É£ Mensaje con Env√≠o Fallido
```javascript
// Estado: status: "failed"
// Metadata: { failureReason, twilioError, retryable }
```

#### üéØ Implementaci√≥n:
```javascript
const renderMessageStatus = (message) => {
  if (message.status === "failed") {
    return (
      <div className="failed-message">
        <IconWarning />
        <span>{message.metadata.failureReason}</span>
        {message.metadata.retryable && <RetryButton />}
      </div>
    );
  }
}
```

### 3Ô∏è‚É£ Token Expirado Durante Procesamiento
```javascript
// Error: 401 con c√≥digo TOKEN_EXPIRED_DURING_PROCESSING
// Acci√≥n: Refresh token autom√°tico + reintentar operaci√≥n
```

#### üéØ Implementaci√≥n:
```javascript
// Interceptor de Axios
axios.interceptors.response.use(
  (response) => response,
  async (error) => {
    if (error.response?.status === 401 && 
        error.response?.data?.code === 'TOKEN_EXPIRED_DURING_PROCESSING') {
      await refreshToken();
      return axios.request(error.config); // Reintentar
    }
    return Promise.reject(error);
  }
);
```

### 4Ô∏è‚É£ Rate Limiting
```javascript
// Headers: X-RateLimit-Remaining, X-RateLimit-Reset
// Error: 429 con retryAfter
```

#### üéØ Implementaci√≥n:
```javascript
const handleRateLimit = (response) => {
  const remaining = response.headers['X-RateLimit-Remaining'];
  const reset = response.headers['X-RateLimit-Reset'];
  
  if (remaining < 5) {
    showWarning("Est√°s cerca del l√≠mite de peticiones");
  }
}

const handle429Error = (error) => {
  const retryAfter = error.response?.data?.retryAfter;
  showError(`Has excedido el l√≠mite. Intenta de nuevo en ${retryAfter}`);
}
```

### 5Ô∏è‚É£ Reconexi√≥n de WebSocket
```javascript
// Evento: socket.on('disconnect')
// Acci√≥n: Reconexi√≥n con exponential backoff
```

#### üéØ Implementaci√≥n:
```javascript
class SocketManager {
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  
  reconnect() {
    const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);
    
    setTimeout(() => {
      this.connect();
      this.emit('sync-state'); // Sincronizar estado
    }, delay);
  }
}
```

### 6Ô∏è‚É£ Eventos de Escritura ("User is Typing")
```javascript
// Rate limit: M√°ximo 2 eventos por segundo por usuario
// Debounce: 500ms para evitar sobrecarga
```

#### üéØ Implementaci√≥n:
```javascript
class TypingManager {
  private lastTypingEvent = 0;
  private typingDebounce = 500;
  
  sendTypingEvent(conversationId: string) {
    const now = Date.now();
    if (now - this.lastTypingEvent > this.typingDebounce) {
      socket.emit('user-typing', { conversationId });
      this.lastTypingEvent = now;
    }
  }
}
```

---

## üöß FUNCIONALIDADES DE BACKEND PENDIENTES

### ‚ö†Ô∏è IMPORTANTE: No Inventar Datos
**NO intentar resolver desde el frontend con datos ficticios**

### 1Ô∏è‚É£ Asignaci√≥n Autom√°tica de Agentes
#### Estado Actual:
- Funci√≥n `getAgentWorkload()` **siempre retorna 0** (hardcodeado)
- L√≥gica de auto-asignaci√≥n **NO est√° operativa**

#### üéØ Manejo en Frontend:
```javascript
// ‚ùå NO hacer esto
const autoAssign = () => {
  // L√≥gica ficticia de asignaci√≥n
}

// ‚úÖ Hacer esto
const handleManualAssignment = () => {
  // Solo asignaci√≥n manual por ahora
  showMessage("Asignaci√≥n autom√°tica no disponible");
}
```

### 2Ô∏è‚É£ Invitaci√≥n de Miembros por Email
#### Estado Actual:
- Endpoint crea usuario con contrase√±a temporal
- **NO env√≠a email** (TODO pendiente)
- Response dice que se envi√≥ email (incorrecto)

#### üéØ Manejo en Frontend:
```javascript
const inviteMember = async (email) => {
  const response = await api.post('/team/invite', { email });
  
  // ‚úÖ Mostrar realidad
  showMessage(`Usuario creado. Contrase√±a temporal: ${response.password}`);
  showWarning("Debes enviar manualmente la contrase√±a por email");
}
```

### 3Ô∏è‚É£ Detecci√≥n de Contactos Duplicados
#### Estado Actual:
- **NO hay l√≥gica** para evitar duplicados
- Pueden existir contactos con mismo tel√©fono

#### üéØ Manejo en Frontend:
```javascript
// ‚úÖ Mostrar todos los duplicados
const renderContacts = (contacts) => {
  return contacts.map(contact => (
    <ContactItem 
      key={`${contact.phone}-${contact.id}`}
      contact={contact}
      showDuplicate={true}
    />
  ));
}
```

### 4Ô∏è‚É£ Transcripci√≥n de Audio
#### Estado Actual:
- AudioProcessor **NO implementa** transcripci√≥n
- TODO pendiente para integrar OpenAI Whisper

#### üéØ Manejo en Frontend:
```javascript
const renderAudioMessage = (message) => {
  return (
    <div>
      <AudioPlayer src={message.audioUrl} />
      {message.transcription ? (
        <p>{message.transcription}</p>
      ) : (
        <p className="text-muted">Transcripci√≥n no disponible</p>
      )}
    </div>
  );
}
```

### üîß Funcionalidades Pendientes Espec√≠ficas (OBLIGATORIAS)
```javascript
const PENDING_FEATURES = {
  // Asignaci√≥n autom√°tica
  autoAssignment: {
    status: 'NOT_IMPLEMENTED',
    backendFunction: 'getAgentWorkload()',
    currentBehavior: 'Siempre retorna 0',
    frontendAction: 'Solo asignaci√≥n manual disponible'
  },
  
  // Env√≠o de emails
  emailInvitations: {
    status: 'NOT_IMPLEMENTED',
    backendFunction: 'sendInvitationEmail()',
    currentBehavior: 'Crea usuario pero no env√≠a email',
    frontendAction: 'Mostrar contrase√±a temporal al usuario'
  },
  
  // Detecci√≥n de duplicados
  duplicateDetection: {
    status: 'NOT_IMPLEMENTED',
    backendFunction: 'checkDuplicateContacts()',
    currentBehavior: 'No verifica duplicados',
    frontendAction: 'Mostrar todos los contactos, incluir duplicados'
  },
  
  // Transcripci√≥n de audio
  audioTranscription: {
    status: 'NOT_IMPLEMENTED',
    backendFunction: 'transcribeAudio()',
    currentBehavior: 'No procesa audio',
    frontendAction: 'Mostrar "Transcripci√≥n no disponible"'
  }
};
```

### 2Ô∏è‚É£ Invitaci√≥n de Miembros por Email
#### Estado Actual:
- Endpoint crea usuario con contrase√±a temporal
- **NO env√≠a email** (TODO pendiente)
- Response dice que se envi√≥ email (incorrecto)

#### üéØ Manejo en Frontend:
```javascript
const inviteMember = async (email) => {
  const response = await api.post('/team/invite', { email });
  
  // ‚úÖ Mostrar realidad
  showMessage(`Usuario creado. Contrase√±a temporal: ${response.password}`);
  showWarning("Debes enviar manualmente la contrase√±a por email");
}
```

### 3Ô∏è‚É£ Detecci√≥n de Contactos Duplicados
#### Estado Actual:
- **NO hay l√≥gica** para evitar duplicados
- Pueden existir contactos con mismo tel√©fono

#### üéØ Manejo en Frontend:
```javascript
// ‚úÖ Mostrar todos los duplicados
const renderContacts = (contacts) => {
  return contacts.map(contact => (
    <ContactItem 
      key={`${contact.phone}-${contact.id}`}
      contact={contact}
      showDuplicate={true}
    />
  ));
}
```

### 4Ô∏è‚É£ Transcripci√≥n de Audio
#### Estado Actual:
- AudioProcessor **NO implementa** transcripci√≥n
- TODO pendiente para integrar OpenAI Whisper

#### üéØ Manejo en Frontend:
```javascript
const renderAudioMessage = (message) => {
  return (
    <div>
      <AudioPlayer src={message.audioUrl} />
      {message.transcription ? (
        <p>{message.transcription}</p>
      ) : (
        <p className="text-muted">Transcripci√≥n no disponible</p>
      )}
    </div>
  );
}
```

---

## ‚úÖ CHECKLIST ESENCIAL PARA EL FRONTEND

### üîê Autenticaci√≥n y Sesiones

- [ ] **Interceptor global para refresh token**
  ```javascript
  // Manejar 401 autom√°ticamente
  // Incluir TOKEN_EXPIRED_DURING_PROCESSING
  ```

- [ ] **Logout sincronizado en todas las pesta√±as**
  ```javascript
  // Usar storage events
  window.addEventListener('storage', handleLogout);
  ```

- [ ] **Validaci√≥n de JWT en cliente** (opcional)
  ```javascript
  // Verificar expiraci√≥n antes de enviar
  ```



---

## üéØ USO DE DATOS REALES

### ‚úÖ Principio Fundamental
**"Datos verdaderos siempre"** - NO usar *mock data*

### üîß Configuraci√≥n de Entornos
```javascript
// Variables de entorno exactas
const ENV_CONFIG = {
  development: {
    API_URL: 'http://localhost:3001/api',
    SOCKET_URL: 'http://localhost:3001',
    FRONTEND_URL: 'http://localhost:5173'
  },
  production: {
    API_URL: 'https://utalk-backend-production.up.railway.app/api',
    SOCKET_URL: 'https://utalk-backend-production.up.railway.app',
    FRONTEND_URL: 'https://utalk-frontend-glt2.vercel.app'
  }
};

// Credenciales de prueba
const TEST_CREDENTIALS = {
  admin: {
    email: 'admin@company.com',
    password: '123456'
  },
  agent: {
    email: 'agent@company.com', 
    password: '123456'
  },
  viewer: {
    email: 'viewer@company.com',
    password: '123456'
  }
};
```

### üêõ Logs y Debugging
- **Errores 401, 403, 429**: Logs detallados en consola para debugging
- **Notificaciones**: Mostrar al usuario errores importantes
- **Nunca ocultar**: Errores cr√≠ticos deben ser visibles
- **Tracking de errores**: Monitorear patrones de errores

### üö´ Lo que NO hacer
```javascript
// ‚ùå NO crear datos ficticios
const mockConversations = [
  { id: 1, name: "Cliente 1", messages: [] },
  { id: 2, name: "Cliente 2", messages: [] }
];

// ‚úÖ Consumir API real
const conversations = await api.get('/conversations');
```

### ‚úÖ Lo que S√ç hacer
```javascript
// ‚úÖ Manejar respuesta vac√≠a
if (conversations.length === 0) {
  return <EmptyState message="No hay conversaciones a√∫n" />;
}

// ‚úÖ Mostrar realidad de datos
const contactName = contact.name || contact.phone || "Sin nombre";
const assignedAgent = conversation.assignedTo?.name || "Sin asignar";
const messageContent = message.content || message.mediaUrl || "[Sin contenido]";
```

### ‚úÖ Lo que S√ç hacer
```javascript
// ‚úÖ Manejar respuesta vac√≠a
if (conversations.length === 0) {
  return <EmptyState message="No hay conversaciones a√∫n" />;
}

// ‚úÖ Mostrar realidad de datos
const contactName = contact.name || contact.phone || "Sin nombre";
```

### üîç Beneficios de Datos Reales
- **Detecci√≥n temprana** de problemas de integraci√≥n
- **Formato real** de datos desde el d√≠a uno
- **Cambios autom√°ticos** si el backend modifica estructura
- **Confianza** en que la UI refleja el estado real

---
