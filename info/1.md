# ğŸš€ PLAN COMPLETO DE DESARROLLO FRONTEND - UTALK

## ğŸ¯ **CONTEXTO CRÃTICO PARA LA IA DE FRONTEND**

### ğŸ“‹ **Â¿QUÃ‰ VAS A CONSTRUIR?**
Un **sistema de chat empresarial completo** que incluye:
- **AutenticaciÃ³n robusta** con JWT y refresh tokens
- **GestiÃ³n de conversaciones** con asignaciÃ³n de agentes
- **Chat en tiempo real** con Socket.IO
- **Sistema de mensajes** con archivos adjuntos
- **GestiÃ³n de contactos** y perfiles
- **Sistema de roles** (admin, agent, viewer)
- **Notificaciones** y estados en tiempo real

### ğŸ”§ **Â¿CÃ“MO LO VAS A CONSTRUIR?**
- **React/Svelte/Vue** con TypeScript
- **Socket.IO Client** para tiempo real
- **Axios/Fetch** para APIs REST
- **Estado global** (Redux/Zustand/Svelte stores)
- **Validaciones** del lado cliente
- **Manejo de errores** especÃ­fico
- **UI responsive** y accesible

### âš ï¸ **Â¿QUÃ‰ DEBES TOMAR EN CUENTA?**
- **NUNCA inventar datos** - Usar solo informaciÃ³n real del backend
- **Seguir exactamente** las estructuras JSON del backend
- **Manejar TODOS los casos especiales** documentados
- **Validar antes de enviar** - No confiar en validaciones del servidor
- **Manejar reconexiones** automÃ¡ticas de Socket.IO
- **Mostrar estados de carga** y errores apropiados
- **Implementar rate limiting** del lado cliente
- **Manejar tokens expirados** automÃ¡ticamente

### ğŸš¨ **REGLAS FUNDAMENTALES:**
1. **DocumentaciÃ³n = Fuente Ãºnica de verdad**
2. **Datos reales siempre** - NO mocks
3. **Validaciones coherentes** con el backend
4. **Manejo robusto de errores**
5. **UX consistente** en todos los estados
6. **Performance optimizada** para tiempo real

---

## ğŸ“‹ ÃNDICE
1. [Importancia de la DocumentaciÃ³n de Backend](#importancia-de-la-documentaciÃ³n-de-backend)
2. [SeparaciÃ³n de Responsabilidades](#separaciÃ³n-de-responsabilidades)
3. [Manejo de Datos: Formatos, Fechas e IDs](#manejo-de-datos-formatos-fechas-e-ids)
4. [Validaciones y Reglas de Negocio](#validaciones-y-reglas-de-negocio)
5. [Casos Especiales que la UI Debe Manejar](#casos-especiales-que-la-ui-debe-manejar)
6. [Funcionalidades de Backend Pendientes](#funcionalidades-de-backend-pendientes)
7. [Checklist Esencial para el Frontend](#checklist-esencial-para-el-frontend)
8. [Uso de Datos Reales](#uso-de-datos-reales)
9. [ImplementaciÃ³n Paso a Paso](#implementaciÃ³n-paso-a-paso)
10. [Monitoreo y MÃ©tricas](#monitoreo-y-mÃ©tricas)
11. [ğŸ”§ INFORMACIÃ“N TÃ‰CNICA ESPECÃFICA DEL BACKEND](#informaciÃ³n-tÃ©cnica-especÃ­fica-del-backend)
12. [ğŸ“Š ESTRUCTURAS DE DATOS EXACTAS](#estructuras-de-datos-exactas)
13. [ğŸŒ ENDPOINTS Y API COMPLETA](#endpoints-y-api-completa)
14. [ğŸ”Œ EVENTOS SOCKET.IO ESPECÃFICOS](#eventos-socketio-especÃ­ficos)
15. [âš ï¸ CÃ“DIGOS DE ERROR Y CASOS ESPECIALES](#cÃ³digos-de-error-y-casos-especiales)
16. [ğŸ¯ CONFIGURACIÃ“N TÃ‰CNICA EXACTA](#configuraciÃ³n-tÃ©cnica-exacta)
17. [ğŸ“‹ MODELOS JSON COMPLETOS](#modelos-json-completos)
18. [ğŸ”Œ ENDPOINTS REST COMPLETOS](#endpoints-rest-completos)
19. [ğŸ¨ REGLAS Y METADATOS ESPECÃFICOS](#reglas-y-metadatos-especÃ­ficos)
20. [âš ï¸ CASOS LÃMITE Y ERRORES ESPECÃFICOS](#casos-lÃ­mite-y-errores-especÃ­ficos)
21. [ğŸ”„ REGLAS DE NEGOCIO DETALLADAS](#reglas-de-negocio-detalladas)
22. [ğŸ“± CASOS ESPECÃFICOS DE UI](#casos-especÃ­ficos-de-ui)
23. [ğŸ”§ CONFIGURACIÃ“N Y ENTORNOS COMPLETOS](#configuraciÃ³n-y-entornos-completos)
24. [â“ PREGUNTAS ABIERTAS RESUELTAS](#preguntas-abiertas-resueltas)

---

## ğŸ¯ IMPORTANCIA DE LA DOCUMENTACIÃ“N DE BACKEND

### âœ… Principio Fundamental
- **DocumentaciÃ³n exhaustiva** del backend es la **fuente Ãºnica de verdad**
- Contiene todos los *edge cases*, transformaciones implÃ­citas, *side effects* y comportamientos especiales
- **ANTES de construir cualquier funcionalidad**, analizar profundamente el documento
- InformaciÃ³n actualizada al 2025-08-02 con *best practices* y correcciones recientes
- **ESTRUCTURAS DE DATOS EXACTAS** del backend para evitar incompatibilidades

### ğŸš¨ Consecuencias de No Seguir la DocumentaciÃ³n
- Incompatibilidades durante pruebas de integraciÃ³n
- Errores de comunicaciÃ³n entre frontend y backend
- Funcionalidades que no funcionan en producciÃ³n
- **Errores de formato de datos** que causan crashes
- **Incompatibilidad de tipos** entre frontend y backend

---

## ğŸ”„ SEPARACIÃ“N DE RESPONSABILIDADES

### ğŸ“‹ Regla de Oro
**LÃ³gica de negocio compleja = Backend**
**PresentaciÃ³n e interacciÃ³n = Frontend**

### ğŸ¯ Responsabilidades EspecÃ­ficas del Backend
- **CÃ¡lculo de contadores** (unreadCount, messageCount)
- **ActualizaciÃ³n automÃ¡tica** de lastMessage y lastMessageAt
- **Emisiones Socket.IO** en tiempo real
- **Validaciones complejas** de permisos y roles
- **Rate limiting** y control de acceso
- **Procesamiento de archivos** y metadatos
- **GestiÃ³n de estados** de mensajes (sent, delivered, read, failed)

### âŒ Lo que NO debe hacer el Frontend
- Duplicar lÃ³gica ya implementada en el backend
- Intentar replicar actualizaciones automÃ¡ticas del servidor
- Calcular campos que el backend ya calcula dinÃ¡micamente

### âœ… Ejemplos de LÃ³gica que Reside en Backend
Cuando se crea un mensaje, el backend automÃ¡ticamente:
- Marca el Ãºltimo mensaje de la conversaciÃ³n
- Incrementa contadores
- EnvÃ­a emisiones en tiempo real via Socket.IO
- Calcula campos como `isOnline`, `lastSeen`, contadores de mensajes no leÃ­dos
- **Actualiza `lastMessageAt`** en la conversaciÃ³n
- **Incrementa `messageCount`** automÃ¡ticamente
- **Emite evento `new-message`** a todos los participantes
- **Procesa archivos adjuntos** y genera URLs
- **Valida permisos** antes de guardar
- **Aplica rate limiting** por usuario

### ğŸ¯ Responsabilidad del Frontend
- Construir la UI
- Consumir las APIs
- Reaccionar a datos y eventos del backend
- **NO suplantar lÃ³gica de procesamiento**
- **Escuchar eventos Socket.IO** y actualizar UI
- **Mostrar estados en tiempo real** (typing, online, etc.)
- **Manejar reconexiones** automÃ¡ticamente
- **Validar datos de entrada** antes de enviar

---

## ğŸ“Š MANEJO DE DATOS: FORMATOS, FECHAS E IDs

### ğŸ“… MÃºltiples Formatos de Fecha
El backend puede responder con **6 formatos distintos**:

1. **ISO string** - `"2025-01-15T10:30:00Z"`
2. **Objetos Firestore** - `{_seconds: 1705312200, _nanoseconds: 0}`
3. **Timestamp numÃ©rico** - `1705312200000`
4. **null** - `null`
5. **undefined** - `undefined`
6. **Otros formatos especÃ­ficos**

### ğŸ”§ FunciÃ³n Utilitaria para Fechas (OBLIGATORIA)
```javascript
const safeDateToISOString = (date) => {
  if (!date) return null;
  
  if (typeof date === 'string') {
    return date;
  }
  
  if (typeof date === 'number') {
    return new Date(date).toISOString();
  }
  
  if (date._seconds) {
    // Firestore timestamp
    return new Date(date._seconds * 1000).toISOString();
  }
  
  if (date instanceof Date) {
    return date.toISOString();
  }
  
  return null;
}
```

### ğŸ” Headers de AutorizaciÃ³n EspecÃ­ficos
- **Login inicial**: Debe incluir `Authorization: Bearer ` (vacÃ­o)
- **Todas las peticiones**: Requieren token JWT vÃ¡lido
- **Interceptor global**: Adjuntar automÃ¡ticamente el header
- **Token vacÃ­o**: Usar cadena vacÃ­a si aÃºn no hay token

### ğŸ”§ ConfiguraciÃ³n de Headers (OBLIGATORIA)
```javascript
// Headers estÃ¡ndar para todas las peticiones
const AUTH_HEADERS = {
  'Authorization': 'Bearer jwt_token_here',
  'Content-Type': 'application/json'
};

// Headers para multipart (archivos)
const MULTIPART_HEADERS = {
  'Authorization': 'Bearer jwt_token_here',
  'Content-Type': 'multipart/form-data'
};

// Headers de rate limiting
const RATE_LIMIT_HEADERS = {
  'X-RateLimit-Limit': '100',
  'X-RateLimit-Remaining': '95', 
  'X-RateLimit-Reset': '1642234567'
};
```

### ğŸ”§ SoluciÃ³n Recomendada
```javascript
// Usar funciÃ³n utilitaria para estandarizar fechas
const safeDateToISOString = (date) => {
  if (!date) return null;
  
  if (typeof date === 'string') {
    return date;
  }
  
  if (typeof date === 'number') {
    return new Date(date).toISOString();
  }
  
  if (date._seconds) {
    // Firestore timestamp
    return new Date(date._seconds * 1000).toISOString();
  }
  
  if (date instanceof Date) {
    return date.toISOString();
  }
  
  return null;
}
```

### ğŸ†” Diferentes Formatos de IDs
- **UUID v4** - Para conversaciones
- **IDs de Firestore** - Cadenas cortas
- **NÃºmeros de telÃ©fono** - Como IDs de contacto
- **IDs propios** - SegÃºn contexto

### ğŸ”§ ValidaciÃ³n de IDs (OBLIGATORIA)
```javascript
// Validar UUID antes de enviar
const isValidUUID = (uuid) => {
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  return uuidRegex.test(uuid);
}

// Validar telÃ©fono internacional
const isValidPhone = (phone) => {
  const phoneRegex = /^\+[1-9]\d{1,14}$/;
  return phoneRegex.test(phone);
}
```

### âœ… ValidaciÃ³n de IDs
```javascript
// Validar UUID antes de enviar
const isValidUUID = (uuid) => {
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  return uuidRegex.test(uuid);
}
```

### âš ï¸ Campos Opcionales o Condicionales
**NUNCA asumir que un campo siempre estarÃ¡ presente**

#### Ejemplos de Campos Condicionales:
- `contact` - Solo si existe contacto relacionado
- `lastMessage` - Solo si hay mensajes en la conversaciÃ³n
- `assignedTo` - Puede ser `null` si no hay agente asignado
- `metadata` - Puede ser `undefined` en mensajes simples
- `readBy` - Solo presente si el mensaje ha sido leÃ­do
- `mediaUrl` - Solo presente en mensajes con archivos

#### ğŸ›¡ï¸ Manejo Seguro:
```javascript
// âœ… Correcto
const contactName = conversation.contact?.name || "Sin nombre";
const lastMessage = conversation.lastMessage || "AÃºn no hay mensajes";
const assignedAgent = conversation.assignedTo?.name || "Sin asignar";
const messageContent = message.content || message.mediaUrl || "[Sin contenido]";

// âŒ Incorrecto
const contactName = conversation.contact.name; // Puede fallar
const lastMessage = conversation.lastMessage.content; // Puede fallar
```

---

## âœ… VALIDACIONES Y REGLAS DE NEGOCIO

### ğŸ“ Validaciones de Entrada (Frontend)
Implementar las **mismas reglas** que el backend:

#### ğŸ“ LÃ­mites de Texto
- **Mensajes**: MÃ¡ximo 4096 caracteres
- **Nombres**: SegÃºn esquemas Joi del backend
- **Descripciones**: LÃ­mites especÃ­ficos por campo

### ğŸ”§ Reglas de ValidaciÃ³n EspecÃ­ficas (OBLIGATORIAS)
```javascript
const VALIDATION_RULES = {
  // Mensajes
  message: {
    content: {
      maxLength: 4096,
      required: true
    },
    type: {
      allowed: ['text', 'image', 'audio', 'video', 'document'],
      default: 'text'
    },
    replyToMessageId: {
      format: 'uuid',
      optional: true
    }
  },
  
  // Conversaciones
  conversation: {
    customerPhone: {
      pattern: /^\+[1-9]\d{1,14}$/,
      required: true
    },
    priority: {
      allowed: ['low', 'normal', 'high', 'urgent'],
      default: 'normal'
    },
    tags: {
      maxItems: 10,
      optional: true
    }
  },
  
  // Archivos
  file: {
    maxSize: 100 * 1024 * 1024, // 100MB
    maxFiles: 10,
    allowedTypes: [
      'image/jpeg', 'image/png', 'image/webp',
      'audio/mp3', 'audio/ogg', 'audio/wav',
      'video/mp4', 'video/webm',
      'application/pdf'
    ],
    blockedExtensions: ['.exe', '.js', '.bat', '.cmd']
  },
  
  // TelÃ©fonos
  phone: {
    pattern: /^\+[1-9]\d{1,14}$/,
    examples: ['+521234567890', '+1234567890']
  }
};
```

#### ğŸ¨ Consideraciones Especiales con Emojis
- **Emojis**: Cuentan como mÃºltiples bytes en validaciÃ³n de longitud
- **ValidaciÃ³n en tiempo real**: Mostrar contador de caracteres restantes
- **LÃ­mite real**: 4096 bytes, no caracteres
- **Contador dinÃ¡mico**: Actualizar mientras el usuario escribe

#### ğŸ“ ValidaciÃ³n de TelÃ©fonos
```javascript
// Formato internacional requerido
const phoneRegex = /^\+[1-9]\d{1,14}$/;
// Ejemplo vÃ¡lido: +521234567890

// FunciÃ³n de validaciÃ³n completa
const validatePhone = (phone) => {
  const phoneRegex = /^\+[1-9]\d{1,14}$/;
  return phoneRegex.test(phone);
}

// NormalizaciÃ³n de telÃ©fono
const normalizePhone = (phone) => {
  // Asegurar formato internacional
  if (phone.startsWith('+')) return phone;
  if (phone.startsWith('52')) return `+${phone}`;
  return `+52${phone}`;
}
```

#### ğŸ“ ValidaciÃ³n de Archivos
- **MÃ¡ximo**: 10 archivos por mensaje
- **TamaÃ±o mÃ¡ximo**: 100MB por archivo
- **Tipos permitidos**: JPEG, PNG, WebP, MP3, OGG, WAV, MP4, WEBM, PDF
- **Tipos bloqueados**: .exe, .js, etc.

```javascript
// FunciÃ³n de validaciÃ³n de archivos completa
const validateFileUpload = (files) => {
  const allowedTypes = [
    'image/jpeg', 'image/png', 'image/webp',
    'audio/mp3', 'audio/ogg', 'audio/wav',
    'video/mp4', 'video/webm',
    'application/pdf'
  ];
  
  const blockedExtensions = ['.exe', '.js', '.bat', '.cmd'];
  
  for (const file of files) {
    if (file.size > 100 * 1024 * 1024) {
      return { valid: false, error: `Archivo ${file.name} excede 100MB` };
    }
    
    if (!allowedTypes.includes(file.type)) {
      return { valid: false, error: `Tipo de archivo no permitido: ${file.type}` };
    }
    
    const extension = file.name.toLowerCase().substring(file.name.lastIndexOf('.'));
    if (blockedExtensions.includes(extension)) {
      return { valid: false, error: `ExtensiÃ³n bloqueada: ${extension}` };
    }
  }
  
  if (files.length > 10) {
    return { valid: false, error: "MÃ¡ximo 10 archivos por mensaje" };
  }
  
  return { valid: true };
}
```

### ğŸ” Reglas de AutorizaciÃ³n
#### ğŸ‘¥ Roles de Usuario
- **viewer**: No puede enviar mensajes ni ver conversaciones
- **agent**: Puede enviar mensajes y ver conversaciones asignadas
- **admin**: Acceso completo

#### ğŸš« Restricciones de Negocio
- **ConversaciÃ³n no asignada**: No se pueden enviar mensajes
- **ReasignaciÃ³n duplicada**: No asignar al mismo agente
- **Rate limiting**: LÃ­mites por usuario e IP

### ğŸ”§ CÃ³digos de Error EspecÃ­ficos (OBLIGATORIOS)
```javascript
const ERROR_CODES = {
  // AutenticaciÃ³n
  'NOT_AUTHENTICATED': 'Usuario no autenticado',
  'TOKEN_EXPIRED': 'Token expirado',
  'TOKEN_EXPIRED_DURING_PROCESSING': 'Token expirado durante el procesamiento',
  'INVALID_TOKEN': 'Token invÃ¡lido',
  'USER_NOT_FOUND': 'Usuario no encontrado',
  'USER_INACTIVE': 'Usuario inactivo',
  
  // Permisos
  'INSUFFICIENT_ROLE': 'Rol insuficiente',
  'USER_NOT_AUTHORIZED': 'Usuario no autorizado',
  'CONVERSATION_NOT_FOUND': 'ConversaciÃ³n no encontrada',
  'MESSAGE_NOT_FOUND': 'Mensaje no encontrado',
  
  // ValidaciÃ³n
  'VALIDATION_ERROR': 'Error de validaciÃ³n',
  'MISSING_CONTENT': 'Contenido faltante',
  'INVALID_PHONE': 'NÃºmero de telÃ©fono invÃ¡lido',
  'FILE_TOO_LARGE': 'Archivo demasiado grande',
  'INVALID_FILE_TYPE': 'Tipo de archivo invÃ¡lido',
  
  // Rate Limiting
  'RATE_LIMIT_EXCEEDED': 'LÃ­mite de peticiones excedido',
  'TOO_MANY_REQUESTS': 'Demasiadas peticiones',
  
  // Negocio
  'CONVERSATION_NOT_ASSIGNED': 'ConversaciÃ³n no asignada',
  'AGENT_NOT_FOUND': 'Agente no encontrado',
  'DUPLICATE_ASSIGNMENT': 'AsignaciÃ³n duplicada',
  
  // Sistema
  'INTERNAL_SERVER_ERROR': 'Error interno del servidor',
  'SERVICE_UNAVAILABLE': 'Servicio no disponible',
  'DATABASE_ERROR': 'Error de base de datos'
};
```

### ğŸ”§ ImplementaciÃ³n de Validaciones
```javascript
// Ejemplo: ValidaciÃ³n de mensaje con emojis
const validateMessage = (text) => {
  // Contar bytes reales, no caracteres
  const byteLength = new TextEncoder().encode(text).length;
  
  if (byteLength > 4096) {
    return { 
      valid: false, 
      error: `Mensaje demasiado largo (${byteLength}/4096 bytes)` 
    };
  }
  return { valid: true, remaining: 4096 - byteLength };
}

// ValidaciÃ³n de telÃ©fono con regex especÃ­fica
const validatePhone = (phone) => {
  const phoneRegex = /^\+[1-9]\d{1,14}$/;
  return phoneRegex.test(phone);
}

// ValidaciÃ³n de archivos con tipos especÃ­ficos
const validateFileUpload = (files) => {
  const allowedTypes = [
    'image/jpeg', 'image/png', 'image/webp',
    'audio/mp3', 'audio/ogg', 'audio/wav',
    'video/mp4', 'video/webm',
    'application/pdf'
  ];
  
  const blockedExtensions = ['.exe', '.js', '.bat', '.cmd'];
  
  for (const file of files) {
    if (file.size > 100 * 1024 * 1024) {
      return { valid: false, error: `Archivo ${file.name} excede 100MB` };
    }
    
    if (!allowedTypes.includes(file.type)) {
      return { valid: false, error: `Tipo de archivo no permitido: ${file.type}` };
    }
    
    const extension = file.name.toLowerCase().substring(file.name.lastIndexOf('.'));
    if (blockedExtensions.includes(extension)) {
      return { valid: false, error: `ExtensiÃ³n bloqueada: ${extension}` };
    }
  }
  
  if (files.length > 10) {
    return { valid: false, error: "MÃ¡ximo 10 archivos por mensaje" };
  }
  
  return { valid: true };
}

// ValidaciÃ³n de permisos por rol
const validatePermissions = (userRole, action, resource) => {
  const permissions = {
    viewer: ['read_conversations'],
    agent: ['read_conversations', 'write_messages', 'assign_conversations'],
    admin: ['read_conversations', 'write_messages', 'assign_conversations', 'manage_users', 'view_stats']
  };
  
  return permissions[userRole]?.includes(action) || false;
}
```

---

## âš ï¸ CASOS ESPECIALES QUE LA UI DEBE MANEJAR

### 1ï¸âƒ£ ConversaciÃ³n Sin Agente Asignado
```javascript
// Estado: assignedTo: null
// Comportamiento: Backend rechaza mensajes (error 403)
// UI debe: Deshabilitar entrada de mensaje
```

#### ğŸ¯ ImplementaciÃ³n:
```javascript
const canSendMessage = (conversation) => {
  return conversation.assignedTo !== null;
}

// En la UI
if (!canSendMessage(conversation)) {
  showWarning("Asigna un agente antes de responder");
  disableMessageInput();
}
```

### 2ï¸âƒ£ Mensaje con EnvÃ­o Fallido
```javascript
// Estado: status: "failed"
// Metadata: { failureReason, twilioError, retryable }
```

#### ğŸ¯ ImplementaciÃ³n:
```javascript
const renderMessageStatus = (message) => {
  if (message.status === "failed") {
    return (
      <div className="failed-message">
        <IconWarning />
        <span>{message.metadata.failureReason}</span>
        {message.metadata.retryable && <RetryButton />}
      </div>
    );
  }
}
```

### 3ï¸âƒ£ Token Expirado Durante Procesamiento
```javascript
// Error: 401 con cÃ³digo TOKEN_EXPIRED_DURING_PROCESSING
// AcciÃ³n: Refresh token automÃ¡tico + reintentar operaciÃ³n
```

#### ğŸ¯ ImplementaciÃ³n:
```javascript
// Interceptor de Axios
axios.interceptors.response.use(
  (response) => response,
  async (error) => {
    if (error.response?.status === 401 && 
        error.response?.data?.code === 'TOKEN_EXPIRED_DURING_PROCESSING') {
      await refreshToken();
      return axios.request(error.config); // Reintentar
    }
    return Promise.reject(error);
  }
);
```

### 4ï¸âƒ£ Rate Limiting
```javascript
// Headers: X-RateLimit-Remaining, X-RateLimit-Reset
// Error: 429 con retryAfter
```

#### ğŸ¯ ImplementaciÃ³n:
```javascript
const handleRateLimit = (response) => {
  const remaining = response.headers['X-RateLimit-Remaining'];
  const reset = response.headers['X-RateLimit-Reset'];
  
  if (remaining < 5) {
    showWarning("EstÃ¡s cerca del lÃ­mite de peticiones");
  }
}

const handle429Error = (error) => {
  const retryAfter = error.response?.data?.retryAfter;
  showError(`Has excedido el lÃ­mite. Intenta de nuevo en ${retryAfter}`);
}
```

### 5ï¸âƒ£ ReconexiÃ³n de WebSocket
```javascript
// Evento: socket.on('disconnect')
// AcciÃ³n: ReconexiÃ³n con exponential backoff
```

#### ğŸ¯ ImplementaciÃ³n:
```javascript
class SocketManager {
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  
  reconnect() {
    const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);
    
    setTimeout(() => {
      this.connect();
      this.emit('sync-state'); // Sincronizar estado
    }, delay);
  }
}
```

### 6ï¸âƒ£ Eventos de Escritura ("User is Typing")
```javascript
// Rate limit: MÃ¡ximo 2 eventos por segundo por usuario
// Debounce: 500ms para evitar sobrecarga
```

#### ğŸ¯ ImplementaciÃ³n:
```javascript
class TypingManager {
  private lastTypingEvent = 0;
  private typingDebounce = 500;
  
  sendTypingEvent(conversationId: string) {
    const now = Date.now();
    if (now - this.lastTypingEvent > this.typingDebounce) {
      socket.emit('user-typing', { conversationId });
      this.lastTypingEvent = now;
    }
  }
}
```

### ğŸ”§ Casos Especiales EspecÃ­ficos (OBLIGATORIOS)
```javascript
const SPECIAL_CASES = {
  // ConversaciÃ³n sin agente asignado
  unassignedConversation: {
    condition: 'conversation.assignedTo === null',
    behavior: 'No se pueden enviar mensajes',
    errorCode: 'CONVERSATION_NOT_ASSIGNED',
    uiAction: 'Deshabilitar input de mensaje, mostrar warning'
  },
  
  // Mensaje fallido
  failedMessage: {
    condition: 'message.status === "failed"',
    metadata: {
      failureReason: 'Error de Twilio',
      retryable: true,
      twilioError: 'Invalid phone number'
    },
    uiAction: 'Mostrar mensaje en rojo, botÃ³n de reintentar'
  },
  
  // Token expirado durante procesamiento
  tokenExpiredDuringProcessing: {
    condition: 'error.code === "TOKEN_EXPIRED_DURING_PROCESSING"',
    action: 'Refresh token automÃ¡tico + reintentar operaciÃ³n',
    uiAction: 'Mostrar loading, no mostrar error al usuario'
  },
  
  // Rate limiting
  rateLimitExceeded: {
    condition: 'error.code === "RATE_LIMIT_EXCEEDED"',
    headers: {
      'X-RateLimit-Remaining': '0',
      'X-RateLimit-Reset': '1642234567'
    },
    uiAction: 'Mostrar error con tiempo de espera'
  },
  
  // ReconexiÃ³n de Socket
  socketReconnection: {
    trigger: 'socket.on("disconnect")',
    action: 'ReconexiÃ³n con exponential backoff',
    backoff: [1000, 2000, 5000, 10000, 30000],
    maxAttempts: 5,
    uiAction: 'Mostrar indicador de reconexiÃ³n'
  }
};
```

### 2ï¸âƒ£ Mensaje con EnvÃ­o Fallido
```javascript
// Estado: status: "failed"
// Metadata: { failureReason, twilioError, retryable }
```

#### ğŸ¯ ImplementaciÃ³n:
```javascript
const renderMessageStatus = (message) => {
  if (message.status === "failed") {
    return (
      <div className="failed-message">
        <IconWarning />
        <span>{message.metadata.failureReason}</span>
        {message.metadata.retryable && <RetryButton />}
      </div>
    );
  }
}
```

### 3ï¸âƒ£ Token Expirado Durante Procesamiento
```javascript
// Error: 401 con cÃ³digo TOKEN_EXPIRED_DURING_PROCESSING
// AcciÃ³n: Refresh token automÃ¡tico + reintentar operaciÃ³n
```

#### ğŸ¯ ImplementaciÃ³n:
```javascript
// Interceptor de Axios
axios.interceptors.response.use(
  (response) => response,
  async (error) => {
    if (error.response?.status === 401 && 
        error.response?.data?.code === 'TOKEN_EXPIRED_DURING_PROCESSING') {
      await refreshToken();
      return axios.request(error.config); // Reintentar
    }
    return Promise.reject(error);
  }
);
```

### 4ï¸âƒ£ Rate Limiting
```javascript
// Headers: X-RateLimit-Remaining, X-RateLimit-Reset
// Error: 429 con retryAfter
```

#### ğŸ¯ ImplementaciÃ³n:
```javascript
const handleRateLimit = (response) => {
  const remaining = response.headers['X-RateLimit-Remaining'];
  const reset = response.headers['X-RateLimit-Reset'];
  
  if (remaining < 5) {
    showWarning("EstÃ¡s cerca del lÃ­mite de peticiones");
  }
}

const handle429Error = (error) => {
  const retryAfter = error.response?.data?.retryAfter;
  showError(`Has excedido el lÃ­mite. Intenta de nuevo en ${retryAfter}`);
}
```

### 5ï¸âƒ£ ReconexiÃ³n de WebSocket
```javascript
// Evento: socket.on('disconnect')
// AcciÃ³n: ReconexiÃ³n con exponential backoff
```

#### ğŸ¯ ImplementaciÃ³n:
```javascript
class SocketManager {
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  
  reconnect() {
    const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);
    
    setTimeout(() => {
      this.connect();
      this.emit('sync-state'); // Sincronizar estado
    }, delay);
  }
}
```

### 6ï¸âƒ£ Eventos de Escritura ("User is Typing")
```javascript
// Rate limit: MÃ¡ximo 2 eventos por segundo por usuario
// Debounce: 500ms para evitar sobrecarga
```

#### ğŸ¯ ImplementaciÃ³n:
```javascript
class TypingManager {
  private lastTypingEvent = 0;
  private typingDebounce = 500;
  
  sendTypingEvent(conversationId: string) {
    const now = Date.now();
    if (now - this.lastTypingEvent > this.typingDebounce) {
      socket.emit('user-typing', { conversationId });
      this.lastTypingEvent = now;
    }
  }
}
```

---

## ğŸš§ FUNCIONALIDADES DE BACKEND PENDIENTES

### âš ï¸ IMPORTANTE: No Inventar Datos
**NO intentar resolver desde el frontend con datos ficticios**

### 1ï¸âƒ£ AsignaciÃ³n AutomÃ¡tica de Agentes
#### Estado Actual:
- FunciÃ³n `getAgentWorkload()` **siempre retorna 0** (hardcodeado)
- LÃ³gica de auto-asignaciÃ³n **NO estÃ¡ operativa**

#### ğŸ¯ Manejo en Frontend:
```javascript
// âŒ NO hacer esto
const autoAssign = () => {
  // LÃ³gica ficticia de asignaciÃ³n
}

// âœ… Hacer esto
const handleManualAssignment = () => {
  // Solo asignaciÃ³n manual por ahora
  showMessage("AsignaciÃ³n automÃ¡tica no disponible");
}
```

### 2ï¸âƒ£ InvitaciÃ³n de Miembros por Email
#### Estado Actual:
- Endpoint crea usuario con contraseÃ±a temporal
- **NO envÃ­a email** (TODO pendiente)
- Response dice que se enviÃ³ email (incorrecto)

#### ğŸ¯ Manejo en Frontend:
```javascript
const inviteMember = async (email) => {
  const response = await api.post('/team/invite', { email });
  
  // âœ… Mostrar realidad
  showMessage(`Usuario creado. ContraseÃ±a temporal: ${response.password}`);
  showWarning("Debes enviar manualmente la contraseÃ±a por email");
}
```

### 3ï¸âƒ£ DetecciÃ³n de Contactos Duplicados
#### Estado Actual:
- **NO hay lÃ³gica** para evitar duplicados
- Pueden existir contactos con mismo telÃ©fono

#### ğŸ¯ Manejo en Frontend:
```javascript
// âœ… Mostrar todos los duplicados
const renderContacts = (contacts) => {
  return contacts.map(contact => (
    <ContactItem 
      key={`${contact.phone}-${contact.id}`}
      contact={contact}
      showDuplicate={true}
    />
  ));
}
```

### 4ï¸âƒ£ TranscripciÃ³n de Audio
#### Estado Actual:
- AudioProcessor **NO implementa** transcripciÃ³n
- TODO pendiente para integrar OpenAI Whisper

#### ğŸ¯ Manejo en Frontend:
```javascript
const renderAudioMessage = (message) => {
  return (
    <div>
      <AudioPlayer src={message.audioUrl} />
      {message.transcription ? (
        <p>{message.transcription}</p>
      ) : (
        <p className="text-muted">TranscripciÃ³n no disponible</p>
      )}
    </div>
  );
}
```

### ğŸ”§ Funcionalidades Pendientes EspecÃ­ficas (OBLIGATORIAS)
```javascript
const PENDING_FEATURES = {
  // AsignaciÃ³n automÃ¡tica
  autoAssignment: {
    status: 'NOT_IMPLEMENTED',
    backendFunction: 'getAgentWorkload()',
    currentBehavior: 'Siempre retorna 0',
    frontendAction: 'Solo asignaciÃ³n manual disponible'
  },
  
  // EnvÃ­o de emails
  emailInvitations: {
    status: 'NOT_IMPLEMENTED',
    backendFunction: 'sendInvitationEmail()',
    currentBehavior: 'Crea usuario pero no envÃ­a email',
    frontendAction: 'Mostrar contraseÃ±a temporal al usuario'
  },
  
  // DetecciÃ³n de duplicados
  duplicateDetection: {
    status: 'NOT_IMPLEMENTED',
    backendFunction: 'checkDuplicateContacts()',
    currentBehavior: 'No verifica duplicados',
    frontendAction: 'Mostrar todos los contactos, incluir duplicados'
  },
  
  // TranscripciÃ³n de audio
  audioTranscription: {
    status: 'NOT_IMPLEMENTED',
    backendFunction: 'transcribeAudio()',
    currentBehavior: 'No procesa audio',
    frontendAction: 'Mostrar "TranscripciÃ³n no disponible"'
  }
};
```

### 2ï¸âƒ£ InvitaciÃ³n de Miembros por Email
#### Estado Actual:
- Endpoint crea usuario con contraseÃ±a temporal
- **NO envÃ­a email** (TODO pendiente)
- Response dice que se enviÃ³ email (incorrecto)

#### ğŸ¯ Manejo en Frontend:
```javascript
const inviteMember = async (email) => {
  const response = await api.post('/team/invite', { email });
  
  // âœ… Mostrar realidad
  showMessage(`Usuario creado. ContraseÃ±a temporal: ${response.password}`);
  showWarning("Debes enviar manualmente la contraseÃ±a por email");
}
```

### 3ï¸âƒ£ DetecciÃ³n de Contactos Duplicados
#### Estado Actual:
- **NO hay lÃ³gica** para evitar duplicados
- Pueden existir contactos con mismo telÃ©fono

#### ğŸ¯ Manejo en Frontend:
```javascript
// âœ… Mostrar todos los duplicados
const renderContacts = (contacts) => {
  return contacts.map(contact => (
    <ContactItem 
      key={`${contact.phone}-${contact.id}`}
      contact={contact}
      showDuplicate={true}
    />
  ));
}
```

### 4ï¸âƒ£ TranscripciÃ³n de Audio
#### Estado Actual:
- AudioProcessor **NO implementa** transcripciÃ³n
- TODO pendiente para integrar OpenAI Whisper

#### ğŸ¯ Manejo en Frontend:
```javascript
const renderAudioMessage = (message) => {
  return (
    <div>
      <AudioPlayer src={message.audioUrl} />
      {message.transcription ? (
        <p>{message.transcription}</p>
      ) : (
        <p className="text-muted">TranscripciÃ³n no disponible</p>
      )}
    </div>
  );
}
```

---

## âœ… CHECKLIST ESENCIAL PARA EL FRONTEND

### ğŸ” AutenticaciÃ³n y Sesiones

- [ ] **Interceptor global para refresh token**
  ```javascript
  // Manejar 401 automÃ¡ticamente
  // Incluir TOKEN_EXPIRED_DURING_PROCESSING
  ```

- [ ] **Logout sincronizado en todas las pestaÃ±as**
  ```javascript
  // Usar storage events
  window.addEventListener('storage', handleLogout);
  ```

- [ ] **ValidaciÃ³n de JWT en cliente** (opcional)
  ```javascript
  // Verificar expiraciÃ³n antes de enviar
  ```



---

## ğŸ¯ USO DE DATOS REALES

### âœ… Principio Fundamental
**"Datos verdaderos siempre"** - NO usar *mock data*

### ğŸ”§ ConfiguraciÃ³n de Entornos
```javascript
// Variables de entorno exactas
const ENV_CONFIG = {
  development: {
    API_URL: 'http://localhost:3001/api',
    SOCKET_URL: 'http://localhost:3001',
    FRONTEND_URL: 'http://localhost:5173'
  },
  production: {
    API_URL: 'https://utalk-backend-production.up.railway.app/api',
    SOCKET_URL: 'https://utalk-backend-production.up.railway.app',
    FRONTEND_URL: 'https://utalk-frontend-glt2.vercel.app'
  }
};

// Credenciales de prueba
const TEST_CREDENTIALS = {
  admin: {
    email: 'admin@company.com',
    password: '123456'
  },
  agent: {
    email: 'agent@company.com', 
    password: '123456'
  },
  viewer: {
    email: 'viewer@company.com',
    password: '123456'
  }
};
```

### ğŸ› Logs y Debugging
- **Errores 401, 403, 429**: Logs detallados en consola para debugging
- **Notificaciones**: Mostrar al usuario errores importantes
- **Nunca ocultar**: Errores crÃ­ticos deben ser visibles
- **Tracking de errores**: Monitorear patrones de errores

### ğŸš« Lo que NO hacer
```javascript
// âŒ NO crear datos ficticios
const mockConversations = [
  { id: 1, name: "Cliente 1", messages: [] },
  { id: 2, name: "Cliente 2", messages: [] }
];

// âœ… Consumir API real
const conversations = await api.get('/conversations');
```

### âœ… Lo que SÃ hacer
```javascript
// âœ… Manejar respuesta vacÃ­a
if (conversations.length === 0) {
  return <EmptyState message="No hay conversaciones aÃºn" />;
}

// âœ… Mostrar realidad de datos
const contactName = contact.name || contact.phone || "Sin nombre";
const assignedAgent = conversation.assignedTo?.name || "Sin asignar";
const messageContent = message.content || message.mediaUrl || "[Sin contenido]";
```

### âœ… Lo que SÃ hacer
```javascript
// âœ… Manejar respuesta vacÃ­a
if (conversations.length === 0) {
  return <EmptyState message="No hay conversaciones aÃºn" />;
}

// âœ… Mostrar realidad de datos
const contactName = contact.name || contact.phone || "Sin nombre";
```

### ğŸ” Beneficios de Datos Reales
- **DetecciÃ³n temprana** de problemas de integraciÃ³n
- **Formato real** de datos desde el dÃ­a uno
- **Cambios automÃ¡ticos** si el backend modifica estructura
- **Confianza** en que la UI refleja el estado real

---
