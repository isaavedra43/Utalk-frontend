import { useCallback, useEffect, useMemo, useRef } from 'react';
import { useMutation, useInfiniteQuery } from '@tanstack/react-query';
import { useNavigate, useLocation } from 'react-router-dom';
import type { Conversation, ConversationFilters } from '../types';
import { conversationsService } from '../services/conversations';
import { useChatStore } from '../stores/useChatStore';
import { useWebSocketContext } from '../contexts/useWebSocketContext';
import { useAuthContext } from '../contexts/useAuthContext';
import { sanitizeConversationId, logConversationId, encodeConversationIdForUrl } from '../utils/conversationUtils';
import { infoLog } from '../config/logger';

// NUEVO: Función para normalizar conversaciones según la estructura del backend
const normalizeConversation = (conversation: Conversation): Conversation => {
  // CORREGIDO: Verificar si realmente no hay datos de contacto
  // El backend puede enviar contact con campos undefined, pero eso no significa que no haya datos
  const hasContactData = conversation.contact && (
    conversation.contact.name || 
    conversation.contact.profileName || 
    conversation.contact.phoneNumber || 
    conversation.contact.id ||
    conversation.contact.waId
  );

  if (!hasContactData) {
    // REDUCIR LOGS: Solo mostrar una vez por conversación
    if (import.meta.env.DEV && !conversation.needsContactData) {
      console.warn('⚠️ [DEBUG] Conversación sin datos de contacto:', conversation.id);
    }
    return {
      ...conversation,
      contact: null,
      needsContactData: true
    };
  }
  
  // CORREGIDO: Normalizar la estructura del contacto según el backend
  // Manejar casos donde algunos campos pueden ser undefined
  return {
    ...conversation,
    contact: {
      id: conversation.contact?.id || conversation.customerPhone,
      name: conversation.contact?.name || conversation.contact?.profileName || conversation.customerPhone,
      profileName: conversation.contact?.profileName || conversation.contact?.name,
      phoneNumber: conversation.contact?.phoneNumber || conversation.customerPhone,
      waId: conversation.contact?.waId,
      hasProfilePhoto: conversation.contact?.avatar ? true : false,
      avatar: conversation.contact?.avatar || null,
      channel: conversation.contact?.channel || 'whatsapp',
      lastSeen: conversation.contact?.lastSeen
    },
    needsContactData: false
  };
};

// NUEVO: Singleton mejorado con control de instancias y estabilidad
class ConversationsManager {
  private static instance: ConversationsManager | null = null;
  private listenersRegistered = false;
  private initialSyncTriggered = false;
  private lastSyncTime = 0;
  private syncTimeout: NodeJS.Timeout | null = null;
  private pollingInterval: NodeJS.Timeout | null = null;
  private instanceCount = 0;
  private isStable = false;
  private isInitialized = false; // NUEVO: Flag de inicialización
  private initializationTimeout: NodeJS.Timeout | null = null; // NUEVO: Timeout de inicialización

  static getInstance(): ConversationsManager {
    if (!ConversationsManager.instance) {
      ConversationsManager.instance = new ConversationsManager();
    }
    return ConversationsManager.instance;
  }

  // NUEVO: Método de inicialización controlada
  initialize(): void {
    if (this.isInitialized) {
      return;
    }

    this.isInitialized = true;

    // Marcar como estable después de 1 segundo (reducido de 3s)
    this.initializationTimeout = setTimeout(() => {
      this.isStable = true;
      // Estado estable alcanzado
    }, 1000);
  }

  // NUEVO: Método para registrar instancia con control mejorado
  registerInstance(): void {
    this.instanceCount++;
    // Instancia registrada
    
    // Inicializar si es la primera instancia
    if (this.instanceCount === 1) {
      this.initialize();
    }
  }

  // NUEVO: Método para desregistrar instancia con control mejorado
  unregisterInstance(): void {
    this.instanceCount = Math.max(0, this.instanceCount - 1);
    // Instancia desregistrada
    
    // Solo limpiar si no hay instancias activas Y el estado es estable
    if (this.instanceCount === 0 && this.isStable) {
      this.cleanup();
      // Todas las instancias desmontadas, limpiando
    }
  }

  isStableState(): boolean {
    return this.isStable;
  }

  isInitializedState(): boolean {
    return this.isInitialized;
  }

  getInstanceCount(): number {
    return this.instanceCount;
  }

  isListenersRegistered(): boolean {
    return this.listenersRegistered;
  }

  setListenersRegistered(value: boolean): void {
    // NUEVO: Permitir registro de listeners siempre que no estén ya registrados
    if (this.listenersRegistered && value) {
      // Listeners ya registrados, saltando
      return;
    }
    
    this.listenersRegistered = value;
    // Listeners actualizados
  }

  isInitialSyncTriggered(): boolean {
    return this.initialSyncTriggered;
  }

  setInitialSyncTriggered(value: boolean): void {
    // NUEVO: Permitir sincronización inicial siempre que no esté ya activada
    if (this.initialSyncTriggered && value) {
      // Sincronización inicial ya activada, saltando
      return;
    }
    
    this.initialSyncTriggered = value;
    // Sincronización inicial actualizada
  }

  canSync(): boolean {
    // NUEVO: Permitir sincronización siempre, solo controlar frecuencia
    const now = Date.now();
    if (now - this.lastSyncTime < 2000) {
      return false;
    }
    this.lastSyncTime = now;
    return true;
  }

  setSyncTimeout(timeout: NodeJS.Timeout | null): void {
    if (this.syncTimeout) {
      clearTimeout(this.syncTimeout);
    }
    this.syncTimeout = timeout;
  }

  setPollingInterval(interval: NodeJS.Timeout | null): void {
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval);
    }
    this.pollingInterval = interval;
  }

  hasPollingInterval(): boolean {
    return this.pollingInterval !== null;
  }

  cleanup(): void {
    if (this.syncTimeout) {
      clearTimeout(this.syncTimeout);
      this.syncTimeout = null;
    }
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval);
      this.pollingInterval = null;
    }
    if (this.initializationTimeout) {
      clearTimeout(this.initializationTimeout);
      this.initializationTimeout = null;
    }
    this.listenersRegistered = false;
    this.initialSyncTriggered = false;
    this.isStable = false;
    this.isInitialized = false;
    // Cleanup completado
  }
}

export const useConversations = (filters: ConversationFilters = {}) => {
  const { isAuthenticated, loading: authLoading, isAuthenticating } = useAuthContext();
  const navigate = useNavigate();
  const location = useLocation();
  
  const {
    activeConversation,
    setConversations,
    setActiveConversation,
    updateConversation: updateStoreConversation
  } = useChatStore();

  // WebSocket context
  const { on, off, isConnected, syncState } = useWebSocketContext();

  // NUEVO: Usar singleton mejorado para controlar estado global
  const manager = useMemo(() => {
    const instance = ConversationsManager.getInstance();
    instance.registerInstance();
    return instance;
  }, []);

  // NUEVO: Cleanup al desmontar
  useEffect(() => {
    return () => {
      manager.unregisterInstance();
    };
  }, [manager]);

  // NUEVO: Cleanup adicional para mantener estabilidad
  useEffect(() => {
    // Solo limpiar listeners si realmente se desconecta
    if (!isAuthenticated || !isConnected) {
      // REDUCIDO: Solo loggear en desarrollo
      if (import.meta.env.DEV) {
        console.log('🔌 useConversations - Cleanup por desconexión...');
      }
      manager.setListenersRegistered(false);
    }
  }, [isAuthenticated, isConnected, manager]);

  // Memoizar filters para evitar re-renders innecesarios
  const memoizedFilters = useMemo(() => filters, [filters]);

  // Flag para evitar carrera URL <-> estado durante la selección
  const isSelectingRef = useRef(false);

  // Sincronización con URL - Extraer conversationId de la URL
  const urlConversationId = useMemo(() => {
    const searchParams = new URLSearchParams(location.search);
    const conversationId = searchParams.get('conversation');
    return conversationId ? decodeURIComponent(conversationId) : null;
  }, [location.search]);

  // Sincronizar URL con conversación seleccionada
  useEffect(() => {
    if (activeConversation?.id && activeConversation.id !== urlConversationId) {
      const encodedId = encodeConversationIdForUrl(activeConversation.id);
      const newSearchParams = new URLSearchParams(location.search);
      newSearchParams.set('conversation', encodedId);
      navigate(`${location.pathname}?${newSearchParams.toString()}`, { replace: true });
    }
  }, [activeConversation?.id, urlConversationId, navigate, location.pathname, location.search]);

  // Infinite Query para obtener conversaciones - SOLO DESPUÉS DEL LOGIN
  const {
    data: conversationsData,
    isLoading,
    error,
    refetch,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage
  } = useInfiniteQuery({
    queryKey: ['conversations', memoizedFilters],
    queryFn: ({ pageParam = 1 }) => conversationsService.getConversations({
      ...memoizedFilters,
      page: pageParam,
      limit: 20
    } as ConversationFilters & { page: number; limit: number }),
    initialPageParam: 1,
    getNextPageParam: (lastPage) => {
      if (!lastPage.hasMore) return undefined;
      return lastPage.page + 1;
    },
    staleTime: 30000,
    refetchOnWindowFocus: false,
    enabled: isAuthenticated && !authLoading && !isAuthenticating,
    retry: (failureCount, error) => {
      if (error && typeof error === 'object' && 'response' in error) {
        const apiError = error as { response?: { status?: number } };
        if (apiError.response?.status === 401) {
          return false;
        }
      }
      return failureCount < 3;
    }
  });

  // Obtener conversaciones del store
  const storeConversations = useChatStore((state) => state.conversations);

  // Combinar conversaciones del store y React Query
  const allConversations = useMemo(() => {
    const queryConversations = conversationsData?.pages.flatMap(page => page.conversations) || [];
    
    // NUEVO: Combinar conversaciones del store y React Query
    const allConversations = [...storeConversations, ...queryConversations];
    
    // Combinar y deduplicar conversaciones por ID
    const uniqueConversations = allConversations.reduce((acc, conversation) => {
      const existingIndex = acc.findIndex(conv => conv.id === conversation.id);
      
      if (existingIndex === -1) {
        acc.push(conversation);
      } else {
        const existing = acc[existingIndex];
        const existingTime = new Date(existing.lastMessageAt || existing.createdAt).getTime();
        const newTime = new Date(conversation.lastMessageAt || conversation.createdAt).getTime();
        
        if (newTime > existingTime) {
          acc[existingIndex] = conversation;
        }
      }
      
      return acc;
    }, [] as typeof allConversations);
    
    return uniqueConversations;
  }, [conversationsData?.pages, storeConversations]);

  // Sincronizar datos de React Query al store solo para carga inicial
  useEffect(() => {
    if (isAuthenticated && !authLoading && conversationsData?.pages && storeConversations.length === 0) {
      const queryConversations = conversationsData.pages.flatMap(page => page.conversations);
      if (queryConversations.length > 0) {
        setConversations(queryConversations);
      }
    }
  }, [conversationsData?.pages, setConversations, isAuthenticated, authLoading, storeConversations.length]);

  // Limpiar URL cuando no hay conversación seleccionada
  useEffect(() => {
    if (!activeConversation && urlConversationId) {
      const newSearchParams = new URLSearchParams(location.search);
      newSearchParams.delete('conversation');
      navigate(`${location.pathname}?${newSearchParams.toString()}`, { replace: true });
    }
  }, [activeConversation, urlConversationId, navigate, location.pathname, location.search]);

  // Sincronización con debouncing optimizada - CON CONTROL SINGLETON MEJORADO
  const debouncedSync = useCallback((reason: string) => {
    // NUEVO: Verificar si se puede sincronizar usando el singleton mejorado
    if (!manager.canSync()) {
      // Sincronización no permitida, saltando
      return;
    }

    // NUEVO: Evitar sincronizaciones iniciales múltiples
    if (reason === 'initial-connection' && manager.isInitialSyncTriggered()) {
      // Sincronización inicial ya realizada, saltando
      return;
    }

    // NUEVO: Evitar sincronizaciones periódicas si WebSocket está activo
    if (reason === 'periodic-polling' && manager.isListenersRegistered()) {
      // WebSocket activo, saltando sincronización periódica
      return;
    }

    const debounceTime = reason === 'new-message' ? 300 : 1000;
    
    const timeout = setTimeout(() => {
      if (isAuthenticated && !authLoading && isConnected) {
        // Solicitando sincronización
        
        // NUEVO: Marcar sincronización inicial como realizada
        if (reason === 'initial-connection') {
          manager.setInitialSyncTriggered(true);
        }
        
        syncState();
      }
    }, debounceTime);

    manager.setSyncTimeout(timeout);
  }, [isAuthenticated, authLoading, isConnected, syncState, manager]);

  // Sincronización inicial cuando se conecta el WebSocket - CON CONTROL SINGLETON MEJORADO
  useEffect(() => {
    if (isAuthenticated && !authLoading && isConnected && !manager.isListenersRegistered() && !manager.isInitialSyncTriggered()) {
          // NUEVO: Solo verificar si ya se activó la sincronización inicial
    if (manager.isInitialSyncTriggered()) {
      // Sincronización inicial ya activada, saltando
      return;
    }
      
      // WebSocket conectado, solicitando sincronización inicial
      manager.setInitialSyncTriggered(true);
      
      // Delay reducido para respuesta más rápida
      setTimeout(() => {
        debouncedSync('initial-connection');
      }, 1000);
    }
  }, [isAuthenticated, authLoading, isConnected, debouncedSync, manager]);

  // Polling periódico OPTIMIZADO - solo como fallback cuando WebSocket no funciona
  useEffect(() => {
    if (!isAuthenticated || authLoading || !isConnected) {
      return;
    }

    // NUEVO: Solo verificar si ya hay un polling activo
    if (manager.hasPollingInterval()) {
      // Polling ya activo, saltando
      return;
    }

    // NUEVO: Solo activar polling si no hay listeners registrados (fallback)
    if (manager.isListenersRegistered()) {
      // WebSocket activo, no necesitamos polling
      return;
    }

    // Iniciando polling periódico (fallback)
    
    // Sincronizar cada 60 segundos solo como fallback (aumentado de 30s)
    const interval = setInterval(() => {
      // NUEVO: Solo verificar si el estado es válido antes de cada polling
      if (!isAuthenticated || authLoading || !isConnected) {
        // Estado no válido, saltando polling
        return;
      }
      
      // NUEVO: Solo hacer polling si no hay listeners registrados
      if (manager.isListenersRegistered()) {
        // WebSocket activo, saltando polling
        return;
      }
      
      // Polling periódico - solicitando sincronización
      debouncedSync('periodic-polling');
    }, 60000); // NUEVO: Aumentado a 60 segundos

    manager.setPollingInterval(interval);

    return () => {
      if (manager.hasPollingInterval()) {
        // Deteniendo polling periódico
        manager.setPollingInterval(null);
      }
    };
  }, [isAuthenticated, authLoading, isConnected, debouncedSync, manager]);

  // ESCUCHAR RESPUESTA DE SINCRONIZACIÓN - OPTIMIZADO
  const handleStateSynced = useCallback((data: unknown) => {
    const syncData = data as { 
      conversations: Conversation[]; 
      messages: unknown[]; 
      users: unknown[]; 
      timestamp: string 
    };
    infoLog('✅ useConversations - Estado sincronizado:', syncData);
    
    if (syncData.conversations && syncData.conversations.length > 0) {
      infoLog('📋 useConversations - Actualizando conversaciones sincronizadas:', syncData.conversations.length);
      
      // NUEVO: Normalizar conversaciones antes de actualizar
      console.log('🎉 useConversations - Actualizando conversaciones del servidor:', syncData.conversations.length);
      const normalizedConversations = syncData.conversations.map(normalizeConversation);
      setConversations(normalizedConversations);
    }
  }, [setConversations]);

  // NUEVO: Handler para eventos de webhook de nuevas conversaciones
  const handleWebhookConversationCreated = useCallback((data: unknown) => {
    const eventData = data as { conversation: Conversation };
    console.log('🎉 useConversations - Nueva conversación desde webhook:', eventData.conversation);
    
    if (eventData.conversation) {
      const currentConversations = useChatStore.getState().conversations;
      const existingIndex = currentConversations.findIndex((c: Conversation) => c.id === eventData.conversation.id);
      
      if (existingIndex === -1) {
        console.log('✅ useConversations - Agregando nueva conversación desde webhook:', eventData.conversation.id);
        const normalizedConversation = normalizeConversation(eventData.conversation);
        setConversations([normalizedConversation, ...currentConversations]);
      } else {
        console.log('✅ useConversations - Actualizando conversación existente desde webhook:', eventData.conversation.id);
        const normalizedConversation = normalizeConversation(eventData.conversation);
        updateStoreConversation(eventData.conversation.id, normalizedConversation);
      }
    }
  }, [setConversations, updateStoreConversation]);

  // NUEVO: Handler para eventos de webhook de nuevos mensajes
  const handleWebhookNewMessage = useCallback((data: unknown) => {
    console.log('🎯 useConversations - Handler webhook:new-message llamado con datos:', data);
    console.log('🎯 useConversations - Timestamp del handler:', new Date().toISOString());
    
    const eventData = data as { 
      conversationId: string; 
      message: { content: string; timestamp: string; sender: string };
      conversation?: Conversation;
    };
    console.log('📨 useConversations - Nuevo mensaje desde webhook:', eventData);
    
    // NUEVO: Log del estado actual antes de actualizar
    const currentConversations = useChatStore.getState().conversations;
    console.log('📊 useConversations - Estado actual antes de actualizar:', {
      currentConversationsCount: currentConversations.length,
      currentConversationIds: currentConversations.map(c => c.id)
    });
    
    // NUEVO: Procesar la conversación completa si viene en el evento
    if (eventData.conversation) {
      const currentConversations = useChatStore.getState().conversations;
      const existingIndex = currentConversations.findIndex((c: Conversation) => c.id === eventData.conversation!.id);
      
      if (existingIndex === -1) {
        // NUEVO: Agregar nueva conversación al inicio de la lista
        console.log('✅ useConversations - Agregando nueva conversación desde webhook new-message:', eventData.conversation.id);
        const normalizedConversation = normalizeConversation(eventData.conversation);
        setConversations([normalizedConversation, ...currentConversations]);
      } else {
        // NUEVO: Actualizar conversación existente y moverla al inicio
        console.log('✅ useConversations - Actualizando conversación existente desde webhook new-message:', eventData.conversation.id);
        const updatedConversations = [...currentConversations];
        const normalizedConversation = normalizeConversation(eventData.conversation);
        updatedConversations[existingIndex] = {
          ...updatedConversations[existingIndex],
          ...normalizedConversation,
          updatedAt: new Date().toISOString()
        };
        
        // NUEVO: Reordenar por fecha de actualización (más reciente primero)
        updatedConversations.sort((a, b) => {
          const aTime = new Date(a.updatedAt || a.lastMessageAt || a.createdAt).getTime();
          const bTime = new Date(b.updatedAt || b.lastMessageAt || b.createdAt).getTime();
          return bTime - aTime;
        });
        
        setConversations(updatedConversations);
      }
    } else {
      // NUEVO: Si no viene la conversación completa, actualizar la existente con el nuevo mensaje
      const currentConversation = storeConversations.find((c: Conversation) => c.id === eventData.conversationId);
      if (currentConversation) {
        const updatedConversation = {
          ...currentConversation,
          lastMessageAt: eventData.message.timestamp,
          lastMessage: {
            content: eventData.message.content,
            direction: eventData.message.sender === 'customer' ? 'inbound' as const : 'outbound' as const,
            messageId: `temp_${Date.now()}`, // ID temporal para el último mensaje
            sender: eventData.message.sender === 'customer' ? `customer:${eventData.conversationId}` : `agent:admin@company.com`,
            timestamp: eventData.message.timestamp
          },
          unreadCount: (currentConversation.unreadCount || 0) + 1,
          updatedAt: new Date().toISOString()
        };
        
        // NUEVO: Actualizar en el store y reordenar la lista
        updateStoreConversation(eventData.conversationId, updatedConversation);
        
        // NUEVO: Reordenar conversaciones por fecha de actualización
        const currentConversations = useChatStore.getState().conversations;
        const updatedConversations = [...currentConversations].sort((a, b) => {
          const aTime = new Date(a.updatedAt || a.lastMessageAt || a.createdAt).getTime();
          const bTime = new Date(b.updatedAt || b.lastMessageAt || b.createdAt).getTime();
          return bTime - aTime;
        });
        
        setConversations(updatedConversations);
      }
    }
    
    // NUEVO: Log final de confirmación
    console.log('🎉 useConversations - Handler webhook:new-message completado exitosamente');
  }, [setConversations, updateStoreConversation, storeConversations]);

  // NUEVO: Handlers optimizados con useCallback para evitar re-renders
  const handleConversationEvent = useCallback((data: unknown) => {
    const eventData = data as { conversation: Conversation; timestamp: string };
    console.log('🔌 useConversations - Evento de conversación recibido:', eventData);
    updateStoreConversation(eventData.conversation.id, eventData.conversation);
  }, [updateStoreConversation]);

  const handleNewMessage = useCallback((data: unknown) => {
    const eventData = data as { 
      conversationId: string; 
      message: unknown; 
      timestamp: string;
      isNewConversation?: boolean;
    };
    console.log('🔌 useConversations - Nuevo mensaje recibido:', eventData);
    console.log('🔌 useConversations - Timestamp del handler:', new Date().toISOString());
    
    // NUEVO: Log del estado actual antes de actualizar
    const currentConversations = useChatStore.getState().conversations;
    console.log('📊 useConversations - Estado actual antes de actualizar:', {
      currentConversationsCount: currentConversations.length,
      currentConversationIds: currentConversations.map(c => c.id),
      isNewConversation: eventData.isNewConversation
    });
    
    // NUEVO: Si es una nueva conversación, crear la conversación completa
    if (eventData.isNewConversation) {
      console.log('🆕 useConversations - Procesando nueva conversación desde new-message');
      
      // Extraer información del mensaje para crear la conversación
      const messageData = eventData.message as {
        content: string;
        timestamp: string;
        sender: string;
        metadata?: {
          contact?: {
            phoneNumber: string;
            profileName: string;
          };
        };
      };
      
      const newConversation: Conversation = {
        id: eventData.conversationId,
        customerName: messageData.metadata?.contact?.profileName || 'Cliente sin nombre',
        customerPhone: messageData.metadata?.contact?.phoneNumber || eventData.conversationId.split('_')[1] || '',
        contact: messageData.metadata?.contact ? {
          id: messageData.metadata.contact.phoneNumber,
          name: messageData.metadata.contact.profileName,
          profileName: messageData.metadata.contact.profileName,
          phoneNumber: messageData.metadata.contact.phoneNumber,
          channel: 'whatsapp'
        } : null,
        status: 'open',
        messageCount: 1,
        unreadCount: 1,
        participants: [messageData.metadata?.contact?.phoneNumber || '', 'admin@company.com'],
        tenantId: 'default_tenant',
        workspaceId: 'default_workspace',
        createdAt: messageData.timestamp,
        updatedAt: new Date().toISOString(),
        lastMessageAt: messageData.timestamp,
        lastMessage: {
          content: messageData.content,
          direction: messageData.sender === 'customer' ? 'inbound' as const : 'outbound' as const,
          messageId: `temp_${Date.now()}`,
          sender: messageData.sender === 'customer' ? `customer:${eventData.conversationId}` : `agent:admin@company.com`,
          timestamp: messageData.timestamp
        },
        assignedTo: 'admin@company.com'
      };
      
      console.log('✅ useConversations - Creando nueva conversación:', newConversation);
      
      // Agregar la nueva conversación al inicio de la lista
      setConversations([newConversation, ...currentConversations]);
      
      // NUEVO: Emitir evento para animación de nueva conversación
      window.dispatchEvent(new CustomEvent('new-conversation-added', {
        detail: {
          conversationId: eventData.conversationId,
          conversation: newConversation,
          timestamp: new Date().toISOString()
        }
      }));
      
      console.log('✅ useConversations - Nueva conversación agregada exitosamente');
      return;
    }
    
    // NUEVO: Actualizar conversación existente con nuevo mensaje y reordenar lista
    const currentConversation = storeConversations.find((c: Conversation) => c.id === eventData.conversationId);
    if (currentConversation) {
      const updatedConversation = {
        ...currentConversation,
        lastMessageAt: eventData.timestamp,
        lastMessage: {
          content: typeof eventData.message === 'object' && eventData.message !== null && 'content' in eventData.message 
            ? (eventData.message as { content: string }).content 
            : 'Nuevo mensaje',
          direction: 'inbound' as const,
          messageId: `temp_${Date.now()}`,
          sender: `customer:${eventData.conversationId}`,
          timestamp: eventData.timestamp
        },
        unreadCount: (currentConversation.unreadCount || 0) + 1,
        updatedAt: new Date().toISOString()
      };
      
      // NUEVO: Actualizar en el store
      updateStoreConversation(eventData.conversationId, updatedConversation);
      
      // NUEVO: Reordenar conversaciones por fecha de actualización
      const updatedConversations = [...currentConversations].sort((a, b) => {
        const aTime = new Date(a.updatedAt || a.lastMessageAt || a.createdAt).getTime();
        const bTime = new Date(b.updatedAt || b.lastMessageAt || b.createdAt).getTime();
        return bTime - aTime;
      });
      
      setConversations(updatedConversations);
      
      // NUEVO: Emitir evento para animación de conversación actualizada
      window.dispatchEvent(new CustomEvent('new-conversation-added', {
        detail: {
          conversationId: eventData.conversationId,
          conversation: updatedConversation,
          timestamp: new Date().toISOString()
        }
      }));
      
      console.log('✅ useConversations - Conversación existente actualizada exitosamente');
    } else {
      console.log('⚠️ useConversations - Conversación no encontrada para actualizar:', eventData.conversationId);
    }
    
    // NUEVO: Log final de confirmación
    console.log('🎉 useConversations - Handler new-message completado exitosamente');
  }, [storeConversations, updateStoreConversation, setConversations]);

  const handleMessageRead = useCallback((data: unknown) => {
    const eventData = data as { conversationId: string; messageIds: string[]; timestamp: string };
    console.log('🔌 useConversations - Mensajes marcados como leídos:', eventData);
    
    // Actualizar conversación con mensajes leídos
    const currentConversation = storeConversations.find((c: Conversation) => c.id === eventData.conversationId);
    if (currentConversation) {
      updateStoreConversation(eventData.conversationId, {
        ...currentConversation,
        unreadCount: Math.max(0, (currentConversation.unreadCount || 0) - eventData.messageIds.length)
      });
    }
  }, [storeConversations, updateStoreConversation]);

  const handleConversationJoined = useCallback((data: unknown) => {
    const eventData = data as { conversationId: string; timestamp: string };
    console.log('🔌 useConversations - Usuario se unió a conversación:', eventData);
    updateStoreConversation(eventData.conversationId, {
      updatedAt: eventData.timestamp
    });
  }, [updateStoreConversation]);

  const handleConversationLeft = useCallback((data: unknown) => {
    const eventData = data as { conversationId: string; timestamp: string };
    console.log('🔌 useConversations - Usuario salió de conversación:', eventData);
    updateStoreConversation(eventData.conversationId, {
      updatedAt: eventData.timestamp
    });
  }, [updateStoreConversation]);

  // ESCUCHAR EVENTOS DE CONVERSACIÓN - OPTIMIZADO PARA EVITAR RECONEXIONES
  useEffect(() => {
    if (!isAuthenticated || authLoading || !isConnected) {
      if (import.meta.env.VITE_DEBUG === 'true') {
        console.debug('[DEBUG][Conversations] No registrando listeners', { 
          isAuthenticated, 
          authLoading, 
          isConnected 
        });
      }
      return;
    }

    // NUEVO: Usar singleton mejorado para evitar registro duplicado
    if (manager.isListenersRegistered()) {
      if (import.meta.env.VITE_DEBUG === 'true') {
        console.debug('[DEBUG][Conversations] Listeners ya registrados, saltando');
      }
      return;
    }

    if (import.meta.env.VITE_DEBUG === 'true') {
      console.debug('[DEBUG][Conversations] Registrando listeners de WS');
    }

    // Registrar listeners para eventos de conversación
    on('conversation-event', handleConversationEvent);
    on('new-message', handleNewMessage);
    on('message-read', handleMessageRead);
    on('conversation-joined', handleConversationJoined);
    on('conversation-left', handleConversationLeft);
    on('state-synced', handleStateSynced);
    
    // NUEVO: Registrar listeners para eventos de webhook
    on('webhook:conversation-created', handleWebhookConversationCreated);
    on('webhook:new-message', handleWebhookNewMessage);
    console.log('🔌 useConversations - Listener webhook:new-message registrado correctamente');
    
    // NUEVO: Registrar listeners para eventos personalizados del DOM
    const handleWebSocketStateSynced = (e: Event) => {
      const detail = (e as CustomEvent).detail;
      handleStateSynced(detail);
    };

    const handleWebSocketNewMessage = (e: Event) => {
      const detail = (e as CustomEvent).detail;
      handleNewMessage(detail);
    };

    const handleWebhookConversationCreatedEvent = (e: Event) => {
      const detail = (e as CustomEvent).detail;
      handleWebhookConversationCreated(detail);
    };

    const handleWebhookNewMessageEvent = (e: Event) => {
      const detail = (e as CustomEvent).detail;
      handleWebhookNewMessage(detail);
    };

    window.addEventListener('websocket:state-synced', handleWebSocketStateSynced);
    window.addEventListener('new-message', handleWebSocketNewMessage);
    window.addEventListener('webhook:conversation-created', handleWebhookConversationCreatedEvent);
    window.addEventListener('webhook:new-message', handleWebhookNewMessageEvent);
    
    // NUEVO: Marcar como registrado usando singleton mejorado
    manager.setListenersRegistered(true);

    // NUEVO: Cleanup solo cuando se desmonta el componente o cambia el estado de autenticación
    return () => {
      // Solo limpiar si realmente se está desmontando o desconectando
      if (!isAuthenticated || !isConnected) {
        if (import.meta.env.VITE_DEBUG === 'true') {
          console.debug('[DEBUG][Conversations] Limpiando listeners de WS (desconexión)');
        }
        off('conversation-event');
        off('new-message');
        off('message-read');
        off('conversation-joined');
        off('conversation-left');
        off('state-synced');
        off('webhook:conversation-created');
        off('webhook:new-message');
        
        // Limpiar listeners del DOM
        window.removeEventListener('websocket:state-synced', handleWebSocketStateSynced);
        window.removeEventListener('new-message', handleWebSocketNewMessage);
        window.removeEventListener('webhook:conversation-created', handleWebhookConversationCreatedEvent);
        window.removeEventListener('webhook:new-message', handleWebhookNewMessageEvent);
        
        manager.setListenersRegistered(false);
      }
    };
  }, [isAuthenticated, authLoading, isConnected, on, off, handleConversationEvent, handleNewMessage, handleMessageRead, handleConversationJoined, handleConversationLeft, handleStateSynced, handleWebhookConversationCreated, handleWebhookNewMessage, manager]); // NUEVO: Agregadas todas las dependencias necesarias

  // Cleanup ya manejado arriba

  // Mutation para actualizar conversación
  const updateConversationMutation = useMutation({
    mutationFn: ({ conversationId, updateData }: { conversationId: string; updateData: Partial<Conversation> }) => {
      const sanitizedId = sanitizeConversationId(conversationId);
      if (!sanitizedId) {
        throw new Error(`ID de conversación inválido: ${conversationId}`);
      }
      const encodedId = encodeConversationIdForUrl(sanitizedId);
      return conversationsService.updateConversation(encodedId, updateData);
    },
    onSuccess: (updatedConversation, variables) => {
      updateStoreConversation(variables.conversationId, updatedConversation);
      console.log('✅ useConversations - Conversación actualizada en store');
    }
  });

  // Mutation para marcar como leído
  const markAsReadMutation = useMutation({
    mutationFn: (conversationId: string) => {
      const sanitizedId = sanitizeConversationId(conversationId);
      if (!sanitizedId) {
        throw new Error(`ID de conversación inválido: ${conversationId}`);
      }
      const encodedId = encodeConversationIdForUrl(sanitizedId);
      return conversationsService.markConversationAsRead(encodedId);
    },
    onSuccess: (updatedConversation, variables) => {
      updateStoreConversation(variables, updatedConversation);
      console.log('✅ useConversations - Mensajes marcados como leídos en store');
    }
  });

  // Mutation para cambiar estado
  const changeStatusMutation = useMutation({
    mutationFn: ({ conversationId, status }: { conversationId: string; status: string }) => {
      const sanitizedId = sanitizeConversationId(conversationId);
      if (!sanitizedId) {
        throw new Error(`ID de conversación inválido: ${conversationId}`);
      }
      const encodedId = encodeConversationIdForUrl(sanitizedId);
      return conversationsService.changeConversationStatus(encodedId, status);
    },
    onSuccess: (updatedConversation, variables) => {
      updateStoreConversation(variables.conversationId, updatedConversation);
      console.log('✅ useConversations - Estado de conversación actualizado en store');
    }
  });

  // Cache para evitar errores repetitivos de IDs inválidos
  const invalidIdCache = useRef<Set<string>>(new Set());
  const lastErrorTime = useRef<number>(0);

  const handleInvalidConversationId = useCallback((conversationId: string) => {
    const now = Date.now();
    
    if (invalidIdCache.current.has(conversationId) && (now - lastErrorTime.current) < 30000) {
      return;
    }
    
    invalidIdCache.current.add(conversationId);
    lastErrorTime.current = now;
    
    console.warn('⚠️ ID de conversación inválido:', conversationId, 'decoded:', decodeURIComponent(conversationId));
  }, []);

  // Función para seleccionar conversación
  const selectConversation = useCallback((conversationId: string) => {
    const sanitizedId = sanitizeConversationId(conversationId);
    if (!sanitizedId) {
      handleInvalidConversationId(conversationId);
      return;
    }

    if (activeConversation?.id === sanitizedId) {
      // Conversación ya seleccionada
      return;
    }

    logConversationId(sanitizedId, 'selectConversation');
    const conversation = allConversations.find((conv: Conversation) => conv.id === sanitizedId);
    if (conversation) {
      console.log('✅ useConversations - Seleccionando conversación:', conversation.customerName);
      
      isSelectingRef.current = true;
      setActiveConversation(conversation);
      
      const encodedId = encodeConversationIdForUrl(sanitizedId);
      const newSearchParams = new URLSearchParams(location.search);
      const currentEncoded = new URLSearchParams(location.search).get('conversation');
      
      if (currentEncoded !== encodedId) {
        newSearchParams.set('conversation', encodedId);
        navigate(`${location.pathname}?${newSearchParams.toString()}`, { replace: true });
      }

      setTimeout(() => {
        isSelectingRef.current = false;
      }, 500);
    } else {
      console.warn('⚠️ useConversations - Conversación no encontrada:', sanitizedId);
    }
  }, [allConversations, activeConversation?.id, setActiveConversation, handleInvalidConversationId, navigate, location.pathname, location.search]);

  // Función para limpiar conversación activa
  const clearActiveConversation = useCallback(() => {
    console.log('🧹 useConversations - Limpiando conversación activa');
    setActiveConversation(null);
  }, [setActiveConversation]);

  return {
    conversations: allConversations,
    activeConversation,
    isLoading,
    error,
    selectConversation,
    clearActiveConversation,
    updateConversation: updateConversationMutation.mutate,
    markAsRead: markAsReadMutation.mutate,
    changeStatus: changeStatusMutation.mutate,
    refetch,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage
  };
}; 