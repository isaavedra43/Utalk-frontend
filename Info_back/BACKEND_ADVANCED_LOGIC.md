# BACKEND_ADVANCED_LOGIC.md

> **üìã NOTA IMPORTANTE:** Este documento fue generado autom√°ticamente desde la rama `main` del backend a fecha 2025-08-02. Corresponde exactamente a la l√≥gica implementada en ese momento y sigue los [elementos de calidad de backend](https://github.com/fpereiro/backendqual).

---

## üìë √çNDICE

- [1. Flujos Internos Detallados](#1-flujos-internos-detallados)
- [2. Edge Cases y Comportamiento Especial](#2-edge-cases-y-comportamiento-especial)
- [3. Eventos, Listeners y L√≥gica Asincr√≥nica](#3-eventos-listeners-y-l√≥gica-asincr√≥nica)
- [4. Reglas de Negocio y Validaciones Internas](#4-reglas-de-negocio-y-validaciones-internas)
- [5. Manejo de Sesiones, Tokens y Seguridad](#5-manejo-de-sesiones-tokens-y-seguridad)
- [6. Auditor√≠a de Logs, M√©tricas y Errores](#6-auditor√≠a-de-logs-m√©tricas-y-errores)
- [7. Recomendaciones y TODOs Detectados](#7-recomendaciones-y-todos-detectados)
- [8. Notas Especiales para Frontend y QA](#8-notas-especiales-para-frontend-y-qa)
- [9. Resumen para Frontend y QA](#9-resumen-para-frontend-y-qa)

---

## 1. Flujos Internos Detallados

### üîê Flujo de Autenticaci√≥n Completo

**LOGIN ENDPOINT: `POST /api/auth/login`**

```
1. Request recibido ‚Üí authMiddleware skipeado (ruta p√∫blica)
2. Extraer { email, password } del body
3. Log: 'login_attempt' con email, IP, userAgent
4. Validaci√≥n b√°sica:
   - ¬øemail existe? ¬øpassword existe?
   - Si falta alguno ‚Üí 400 + 'MISSING_CREDENTIALS'
5. Log: 'query_started' para user_validation
6. User.validatePassword(email, password):
   - Buscar usuario en Firestore por email
   - Comparar password con bcrypt (almacenado en plain text - ‚ö†Ô∏è SECURITY ISSUE)
   - Retornar boolean
7. Si password inv√°lido:
   - Log: 'login_failed' con reason: 'invalid_credentials'
   - Incrementar failed attempts (rate limiting interno)
   - Respuesta 401 + 'INVALID_CREDENTIALS'
8. Si password v√°lido:
   - Log: 'login_success'
   - Generar access token (JWT, 15min TTL)
   - Generar refresh token (UUID, 7 d√≠as TTL)
   - Guardar refresh token en Firestore con metadata
   - Log: 'tokens_generated'
   - Respuesta 200 + { accessToken, refreshToken, user }
```

**Diagrama de Flujo:**

```
[Request] ‚Üí [Validar Body] ‚Üí [DB Query] ‚Üí [Password Check]
    ‚Üì              ‚Üì             ‚Üì           ‚Üì
[Log Attempt] [400 Error] [User Found] [bcrypt.compare]
    ‚Üì                          ‚Üì           ‚Üì
[Continue]                [404 Error] [Success/Fail]
    ‚Üì                                      ‚Üì
[Generate Tokens] ‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê [401/200]
    ‚Üì
[Save Refresh Token]
    ‚Üì
[Response + Logs]
```

### üí¨ Flujo de Creaci√≥n de Mensaje

**ENDPOINT: `POST /api/conversations/:conversationId/messages`**

```
1. authMiddleware ‚Üí Validar JWT ‚Üí req.user cargado
2. Extraer conversationId de params
3. Extraer { messageId?, content, type, mediaUrl?, fileMetadata?, replyToMessageId?, metadata? } del body
4. Log: 'processing_started'
5. Validar conversaci√≥n existe:
   - Conversation.getById(conversationId)
   - Si no existe ‚Üí 404 + 'CONVERSATION_NOT_FOUND'
6. Validar permisos de usuario:
   - Si req.user.role === 'viewer' ‚Üí 403 + 'USER_NOT_AUTHORIZED'
7. Validar contenido:
   - Si !content && !mediaUrl ‚Üí 400 + 'MISSING_CONTENT'
8. Generar/validar messageId:
   - Si no viene del frontend ‚Üí generar UUID
   - Log: 'id_generated'
9. Validar mediaUrl (si existe):
   - Debe ser URL v√°lida de Firebase Storage
   - Validar metadata del archivo
10. Crear objeto Message completo
11. Intentar env√≠o v√≠a Twilio (si es outbound):
    - Si falla ‚Üí marcar como 'failed' pero guardar en DB
    - Log: 'twilio_send_attempt'
12. Guardar en Firestore ‚Üí Message.create()
13. Emitir eventos WebSocket:
    - 'new-message' a la conversaci√≥n
    - 'message-sent' al sender
14. Log: 'message_created' + 'socket_emitted'
15. Respuesta 201 + message completo
```

### üîå Flujo de Conexi√≥n WebSocket

**SOCKET CONNECTION FLOW:**

```
1. Cliente conecta a /socket.io con auth: { token }
2. EnterpriseSocketManager.setupAuthenticationMiddleware():
   - Extraer token del handshake.auth
   - Verificar JWT con mismo config que authMiddleware
   - Si inv√°lido ‚Üí disconnectar con error
   - Si v√°lido ‚Üí socket.userId = decodedToken.email
3. Event 'connection':
   - Log: 'socket_connected'
   - Agregar a connectedUsers map
   - Configurar event listeners con cleanup autom√°tico
   - Rate limiting setup por usuario
4. Event 'join-conversation':
   - Validar permisos de usuario en conversaci√≥n
   - Agregar socket a room de conversaci√≥n
   - Actualizar userConversations map
   - Emitir 'conversation-joined'
5. Event 'disconnect':
   - Cleanup autom√°tico de listeners
   - Remover de todas las maps
   - Emitir 'user-offline' si era el √∫ltimo socket
   - Garbage collection trigger cada 100 disconnections
```

---

## 2. Edge Cases y Comportamiento Especial

### üì± Manejo de Mensajes

**Edge Case: Mensaje vac√≠o**

```javascript
// En MessageController.createMessageInConversation()
if (!content && !mediaUrl) {
  throw new ApiError(
    'MISSING_CONTENT',
    'Debes proporcionar contenido o un archivo multimedia',
    400
  );
}
```

**Edge Case: Archivo demasiado grande**

```javascript
// En multer config (MediaUploadController)
limits: {
  fileSize: 100 * 1024 * 1024, // 100MB m√°ximo
  files: 10 // m√°ximo 10 archivos por request
}
```

**Edge Case: Conversaci√≥n inexistente**

```javascript
// Siempre se valida antes de crear mensaje
const conversation = await Conversation.getById(conversationId);
if (!conversation) {
  throw CommonErrors.CONVERSATION_NOT_FOUND(conversationId);
}
```

**Edge Case: Usuario sin permisos**

```javascript
if (req.user.role === 'viewer') {
  throw CommonErrors.USER_NOT_AUTHORIZED('enviar mensajes', conversationId);
}
```

### üîê Autenticaci√≥n y Sesiones

**Edge Case: Token expirado durante request**

```javascript
// En authMiddleware
if (jwtError.name === 'TokenExpiredError') {
  return res.status(401).json({
    error: 'Token inv√°lido',
    message: 'El token ha expirado. Por favor, inicia sesi√≥n de nuevo.',
    code: 'TOKEN_EXPIRED'
  });
}
```

**Edge Case: M√∫ltiples logins simult√°neos**

```javascript
// En AuthController.login - rate limiting aplicado
// M√°ximo 5 intentos por IP por minuto
// Tracked en AdvancedSecurity.failedAttempts Map
```

**Edge Case: Refresh token ya usado**

```javascript
// En RefreshToken.validateAndRotate()
if (token.used) {
  // Invalidar toda la familia de tokens (security breach detection)
  await this.invalidateTokenFamily(token.family);
  throw new Error('Token family compromised');
}
```

### üéÆ WebSocket Edge Cases

**Edge Case: Conexi√≥n perdida durante mensaje**

```javascript
// Socket.IO auto-reconexi√≥n + state sync
socket.emit('sync-state', { conversationIds: [...] });
// Server responde con estado actual de conversaciones
```

**Edge Case: Rate limiting en eventos**

```javascript
// En EnterpriseSocketManager
const RATE_LIMITS = {
  typing: 500, // 0.5 segundos entre eventos
  'new-message': 100, // 0.1 segundos
  'join-conversation': 1000 // 1 segundo
};
```

**Edge Case: Memory leak en listeners**

```javascript
// Cleanup autom√°tico implementado
socket.on('disconnect', () => {
  this.cleanupUserSession(userEmail);
  // Remueve todos los listeners y maps entries
});
```

---

## 3. Eventos, Listeners y L√≥gica Asincr√≥nica

### üîå Socket.IO Events Completos

**Eventos del Cliente ‚Üí Servidor:**

| Evento               | Payload                         | Autenticaci√≥n | Respuesta                      | Descripci√≥n                   |
| -------------------- | ------------------------------- | ------------- | ------------------------------ | ----------------------------- |
| `authenticate`       | `{ token }`                     | ‚ùå            | `authenticated` / `auth-error` | Re-autenticar socket          |
| `join-conversation`  | `{ conversationId }`            | ‚úÖ            | `conversation-joined`          | Unirse a sala de conversaci√≥n |
| `leave-conversation` | `{ conversationId }`            | ‚úÖ            | `conversation-left`            | Salir de sala                 |
| `new-message`        | `{ content, type, mediaUrl? }`  | ‚úÖ            | `message-sent`                 | Enviar mensaje tiempo real    |
| `typing`             | `{ conversationId }`            | ‚úÖ            | `typing` (broadcast)           | Indicador de escribiendo      |
| `typing-stop`        | `{ conversationId }`            | ‚úÖ            | `typing-stop` (broadcast)      | Parar indicador               |
| `message-read`       | `{ messageId, conversationId }` | ‚úÖ            | `message-delivered`            | Marcar como le√≠do             |
| `sync-state`         | `{ conversationIds[] }`         | ‚úÖ            | `state-synced`                 | Sincronizar estado            |

**Eventos del Servidor ‚Üí Cliente:**

| Evento                | Payload                         | Trigger            | Descripci√≥n                   |
| --------------------- | ------------------------------- | ------------------ | ----------------------------- |
| `conversation-joined` | `{ conversationId, user }`      | join-conversation  | Usuario se uni√≥               |
| `conversation-left`   | `{ conversationId, user }`      | leave-conversation | Usuario sali√≥                 |
| `new-message`         | `{ message, conversation }`     | Message created    | Nuevo mensaje en conversaci√≥n |
| `message-sent`        | `{ messageId, status }`         | Message saved      | Confirmaci√≥n de env√≠o         |
| `message-delivered`   | `{ messageId, deliveredAt }`    | Twilio webhook     | Mensaje entregado             |
| `message-read`        | `{ messageId, readAt, readBy }` | Mark as read       | Mensaje le√≠do                 |
| `typing`              | `{ conversationId, user }`      | Typing event       | Alguien est√° escribiendo      |
| `typing-stop`         | `{ conversationId, user }`      | Typing stop        | Par√≥ de escribir              |
| `user-online`         | `{ email, name, lastSeen }`     | Socket connect     | Usuario conectado             |
| `user-offline`        | `{ email, lastSeen }`           | Socket disconnect  | Usuario desconectado          |
| `admin-broadcast`     | `{ message, type, data }`       | Admin action       | Mensaje administrativo        |

### üîÑ L√≥gica Asincr√≥nica Interna

**Background Jobs (NO implementados - uso de setTimeout):**

```javascript
// En MessageService - retry de env√≠o Twilio
setTimeout(async () => {
  await this.retryFailedMessage(messageId);
}, 30000); // 30 segundos
```

**Event Emitters Internos:**

```javascript
// memoryManager events
memoryManager.on('warning-alert', alert => {
  logger.warn('Memory warning', alert);
});

// healthService events
healthService.on('service-down', serviceName => {
  // Notificar a admins v√≠a WebSocket
});
```

**Cleanup Autom√°tico:**

```javascript
// En EnterpriseSocketManager
setInterval(
  () => {
    this.performMemoryCleanup();
  },
  2 * 60 * 1000
); // Cada 2 minutos

setInterval(
  () => {
    this.performMemoryLeakDetection();
  },
  5 * 60 * 1000
); // Cada 5 minutos
```

---

## 4. Reglas de Negocio y Validaciones Internas

### üìù Validaciones de Mensajes

**Longitud de contenido:**

```javascript
// No hay l√≠mite expl√≠cito en c√≥digo, pero Twilio limita:
// - SMS: 1600 caracteres
// - WhatsApp: 4096 caracteres
// Firebase Firestore: 1MB por documento
```

**Tipos de mensaje permitidos:**

```javascript
const validTypes = ['text', 'image', 'audio', 'video', 'document', 'system'];
// Validado en Joi schema en routes/messages.js
```

**Formato de archivos aceptados:**

```javascript
// En MediaUploadController
const allowedMimeTypes = {
  image: ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],
  audio: ['audio/mpeg', 'audio/wav', 'audio/ogg'],
  video: ['video/mp4', 'video/webm', 'video/quicktime'],
  document: ['application/pdf', 'text/plain', 'application/msword']
};
```

### üë• Reglas de Conversaciones

**L√≠mite de participantes:**

```javascript
// No hay l√≠mite expl√≠cito en c√≥digo
// TODO: Implementar l√≠mite configurable por plan
```

**Asignaci√≥n de agentes:**

```javascript
// En ConversationController.assignConversation()
if (!agent.isActive) {
  throw new ApiError('AGENT_INACTIVE', 'El agente est√° inactivo', 400);
}

if (conversation.assignedTo === assignedTo) {
  throw CommonErrors.CONVERSATION_ALREADY_ASSIGNED(id, assignedTo);
}
```

### üîê Reglas de Usuarios y Roles

**Jerarqu√≠a de roles:**

```javascript
// Implementado en middleware/auth.js
const roleHierarchy = ['viewer', 'agent', 'admin', 'superadmin'];

// Permisos por rol:
// - viewer: solo lectura b√°sica
// - agent: lectura + escribir mensajes + gestionar conversaciones asignadas
// - admin: todo menos gesti√≥n de superadmins
// - superadmin: acceso completo
```

**Restricciones por rol:**

```javascript
// viewer no puede:
// - Crear mensajes (MessageController)
// - Asignar conversaciones (ConversationController)
// - Gestionar team (TeamController)
// - Crear campa√±as (CampaignController)
```

### üìÅ Reglas de Archivos

**L√≠mites de almacenamiento:**

```javascript
// Por archivo: 100MB (multer config)
// Por request: m√°ximo 10 archivos
// Almacenamiento en Firebase Storage con CDN
// TODO: L√≠mites por usuario/plan no implementados
```

**Seguridad de archivos:**

```javascript
// Validaci√≥n de MIME type
// Sanitizaci√≥n de nombres de archivo
// URLs firmadas de Firebase Storage (TTL configurable)
// Virus scanning: TODO - no implementado
```

---

## 5. Manejo de Sesiones, Tokens y Seguridad

### üîê Ciclo de Vida de Tokens

**Access Token (JWT):**

```javascript
// Configuraci√≥n en config/jwt.js
{
  secret: process.env.JWT_SECRET,
  expiresIn: '15m',
  issuer: 'utalk-backend',
  audience: 'utalk-frontend'
}
```

**Refresh Token (UUID):**

```javascript
// Configuraci√≥n en config/jwt.js
{
  expiresIn: '7d',
  family: 'uuid-v4', // Para detectar token reuse
  rotateOnUse: true,
  revokeOnSecurity: true
}
```

**Flujo de Renovaci√≥n:**

```
1. Cliente env√≠a refresh token a POST /auth/refresh
2. Validar token no expirado y no usado
3. Marcar token actual como 'usado'
4. Generar nuevo access + refresh token
5. Invalidar token anterior
6. Responder con nuevos tokens
7. Si hay reuso detectado ‚Üí invalidar familia completa
```

### üõ°Ô∏è Medidas de Seguridad Implementadas

**Rate Limiting Adaptativo:**

```javascript
// En AdvancedSecurity
- L√≠mites autom√°ticos seg√∫n carga del sistema
- Fallback Redis ‚Üí Memory store
- Bloqueo temporal por IP sospechosa
- Detecci√≥n de patrones de ataque
```

**Validaciones de Entrada:**

```javascript
// Joi schemas en todos los endpoints
// Sanitizaci√≥n HTML en middleware/sanitization.js
// Validaci√≥n de tel√©fonos con normalizaci√≥n
// Protecci√≥n contra SQL injection, XSS, Path traversal
```

**CORS Seguro:**

```javascript
// En config/cors.js
development: ['localhost:3000', 'localhost:3001', ...],
production: ['https://utalk.com', 'https://app.utalk.com', ...]
// No wildcards (*) en producci√≥n
```

**Headers de Seguridad:**

```javascript
// En index.js setupBasicMiddleware
'X-Content-Type-Options': 'nosniff',
'X-Frame-Options': 'DENY',
'X-XSS-Protection': '1; mode=block',
'Referrer-Policy': 'strict-origin-when-cross-origin'
```

### üîç Sistema de Logs de Seguridad

**Eventos auditables:**

```javascript
// Login attempts (success/failed)
req.logger.auth('login_attempt', { email, ip, userAgent });

// Token validation failures
logger.warn('JWT inv√°lido', { category: 'AUTH_JWT_ERROR', ... });

// Suspicious activity
logger.security('unauthorized_access', { operation, userId, ... });

// Admin actions
logger.admin('user_role_change', { targetUser, newRole, ... });
```

---

## 6. Auditor√≠a de Logs, M√©tricas y Errores

### üìä Estructura de Logs

**Formato JSON estructurado:**

```javascript
{
  timestamp: '2025-08-02T00:47:01.317Z',
  level: 'info',
  message: 'Usuario autenticado exitosamente',
  category: 'AUTH_SUCCESS',
  requestId: 'req_1725234421_abc123def',
  processId: 68686,
  nodeEnv: 'production',
  userEmail: 'user@example.com',
  ip: '192.168.1.100'
}
```

**Categor√≠as de logs:**

```javascript
// En utils/logger.js
- AUTH: autenticaci√≥n y autorizaci√≥n
- DATABASE: operaciones de Firestore
- SOCKET: eventos WebSocket
- MESSAGE: creaci√≥n/env√≠o de mensajes
- SECURITY: eventos de seguridad
- ADMIN: acciones administrativas
- MEDIA: subida/procesamiento de archivos
- TWILIO: integraci√≥n con Twilio
- ERROR: errores y excepciones
- PERFORMANCE: m√©tricas de rendimiento
```

**Filtrado de datos sensibles:**

```javascript
// En logger.js y enhancedErrorHandler.js
const sensitiveFields = [
  'password',
  'token',
  'authorization',
  'secret',
  'key',
  'auth',
  'credential',
  'jwt',
  'refresh_token',
  'api-key'
];
// Autom√°ticamente filtrados como '[FILTERED]'
```

### üö® Sistema de Errores Unificado

**Tipos de error clasificados:**

```javascript
// En enhancedErrorHandler.js
ERROR_TYPES = {
  VALIDATION: 400,
  AUTHENTICATION: 401,
  AUTHORIZATION: 403,
  NOT_FOUND: 404,
  CONFLICT: 409,
  RATE_LIMIT: 429,
  EXTERNAL_SERVICE: 502,
  DATABASE: 503,
  INTERNAL: 500,
  SECURITY: 403
};
```

**Rate limiting de errores:**

```javascript
// Prevenir spam de errores id√©nticos
if (this.isErrorRateLimited(errorContext)) {
  return res.status(429).json({
    error: 'Too many similar errors',
    message: 'Rate limit exceeded for error reporting'
  });
}
```

### üìà M√©tricas y Monitoreo

**M√©tricas autom√°ticas:**

```javascript
// En EnterpriseSocketManager
metrics: {
  connectionsPerSecond: 0,
  messagesPerSecond: 0,
  disconnectionsPerSecond: 0,
  errorsPerSecond: 0,
  lastResetTime: Date.now()
}
```

**Health checks endpoint:**

```
GET /health/detailed ‚Üí Firestore, Storage, Redis, System status
GET /ready ‚Üí Readiness probe para K8s
GET /api/internal/metrics ‚Üí M√©tricas detalladas (auth requerido)
```

**Alertas cr√≠ticas:**

```javascript
// Trigger autom√°tico en:
- Memory usage > 85%
- Error rate > 5 errores/segundo
- External service down > 30 segundos
- Socket connections > 45000
```

---

## 7. Recomendaciones y TODOs Detectados

### üî¥ TODOs Cr√≠ticos Encontrados

**Seguridad:**

```javascript
// src/middleware/auth.js:375-376
requireAgentOrAdmin: requireRole(['admin', 'superadmin', 'agent']), // TODO: Migrar a requireWriteAccess
requireViewerOrHigher: requireReadAccess // TODO: Migrar a requireReadAccess
```

**Implementaciones pendientes:**

```javascript
// TeamController.js - Email sending
// TODO: Implementar env√≠o de email para invitaciones

// ContactController.js - Business rules
// TODO: Implementar l√≥gica real para duplicados

// CampaignController.js - Advanced scheduling
// TODO: Implementar scheduling avanzado de campa√±as
```

### ‚ö†Ô∏è Problemas de Seguridad Identificados

**Contrase√±as en texto plano:**

```javascript
// src/models/User.js - CR√çTICO
// Contrase√±as almacenadas sin hash en Firestore
// URGENTE: Implementar bcrypt.hash() antes de guardar
```

**Validaci√≥n insuficiente:**

```javascript
// Rate limiting por usuario no implementado en WebSocket
// File type validation solo por MIME (spoofeable)
// No hay virus scanning en uploads
```

### üîß Mejoras de Arquitectura Recomendadas

**Background Jobs:**

```javascript
// Implementar queue real (Redis/Bull) en lugar de setTimeout
// Para: retry de mensajes, cleanup de archivos, env√≠o de emails
```

**Caching:**

```javascript
// Implementar Redis caching para:
// - User sessions activas
// - Conversation metadata frecuente
// - File metadata y URLs
```

**Observabilidad:**

```javascript
// A√±adir tracing distribuido (OpenTelemetry)
// M√©tricas de Prometheus
// Dashboard de Grafana
```

---

## 8. Notas Especiales para Frontend y QA

### üé® Para Desarrolladores Frontend

**Reconexi√≥n WebSocket:**

```javascript
// Implementar exponential backoff
const socket = io(WS_URL, {
  auth: { token },
  timeout: 5000,
  retries: 3,
  retryDelay: 1000
});

// Listener obligatorio para sync despu√©s de reconexi√≥n
socket.on('connect', () => {
  socket.emit('sync-state', {
    conversationIds: getActiveConversationIds()
  });
});
```

**Manejo de errores 401:**

```javascript
// Interceptor HTTP para auto-refresh
axios.interceptors.response.use(
  response => response,
  async error => {
    if (error.response?.status === 401 && error.response?.data?.code === 'TOKEN_EXPIRED') {
      await refreshToken();
      return axios.request(error.config);
    }
    throw error;
  }
);
```

**Validaci√≥n client-side obligatoria:**

```javascript
// Implementar misma validaci√≥n Joi en frontend
// Para reducir requests inv√°lidos y mejorar UX
// Especialmente importante para:
- Longitud de mensajes
- Formato de tel√©fonos
- Tama√±o de archivos
- Tipos MIME aceptados
```

**Estados de mensaje:**

```javascript
// Estados progresivos que frontend debe manejar:
'sending' ‚Üí 'sent' ‚Üí 'delivered' ‚Üí 'read' ‚Üí 'failed'

// Reintentos autom√°ticos solo para 'failed' con reason espec√≠fico
// No reintentar errores 400 (validation) o 403 (permission)
```

### üß™ Para QA Testing

**Edge Cases cr√≠ticos a probar:**

1. **Conectividad:**
   - P√©rdida de internet durante env√≠o de mensaje
   - Reconexi√≥n WebSocket con estado inconsistente
   - Timeout en upload de archivos grandes

2. **Concurrencia:**
   - M√∫ltiples usuarios escribiendo simult√°neamente
   - Mismo mensaje enviado desde web y m√≥vil
   - Usuario conectado en m√∫ltiples pesta√±as

3. **L√≠mites y Rate Limiting:**
   - Enviar 100 mensajes en 1 segundo
   - Upload simult√°neo de 10 archivos de 100MB
   - Login failures repetidos (trigger IP blocking)

4. **Errores de servicios externos:**
   - Firebase Firestore down
   - Twilio API returning 503
   - Redis connection lost

**Herramientas de testing recomendadas:**

```bash
# Load testing WebSocket
npx artillery run socket-load-test.yml

# API stress testing
npx artillery run api-stress-test.yml

# Memory leak detection
node --inspect src/index.js
# Conectar Chrome DevTools ‚Üí Memory tab
```

**Simulaci√≥n de errores:**

```javascript
// Usar endpoints de testing (solo en dev)
POST /api/internal/simulate-error
{ type: 'firestore_timeout', duration: 5000 }

POST /api/internal/trigger-memory-pressure
{ targetUsage: 0.85 }
```

### üì± Consideraciones Mobile

**Timeouts ajustados:**

```javascript
// Configurar timeouts m√°s largos en mobile
const API_TIMEOUT = isMobile ? 15000 : 10000;
```

**Optimizaci√≥n de datos:**

```javascript
// Paginaci√≥n m√°s peque√±a en mobile
const PAGE_SIZE = isMobile ? 20 : 50;

// Compresi√≥n de im√°genes antes de upload
// Implementar progressive JPEG loading
```

**Background sync:**

```javascript
// Implementar Service Worker para:
// - Queue de mensajes offline
// - Background sync cuando vuelve conectividad
// - Push notifications
```

---

## 9. Resumen para Frontend y QA

### üö® **CR√çTICO - Implementar Siempre**

1. **Interceptor de 401:** Auto-refresh token en requests HTTP
2. **WebSocket reconnection:** Con state sync obligatorio
3. **Error boundaries:** Para manejar errores 500 inesperados
4. **Loading states:** Para todas las operaciones as√≠ncronas
5. **Offline detection:** Queue de acciones cuando no hay internet

### ‚ö†Ô∏è **IMPORTANTE - Validar Edge Cases**

1. **File uploads > 50MB:** Mostrar progress + cancelaci√≥n
2. **Mensajes largos:** Truncar o dividir autom√°ticamente
3. **M√∫ltiples conexiones:** Detectar y sincronizar estado
4. **Memory leaks:** Cleanup de listeners y components
5. **Rate limiting:** Mostrar mensajes informativos, no errores

### üîß **OPTIMIZACIONES - Performance**

1. **Lazy loading:** Conversaciones e im√°genes
2. **Message pagination:** Infinite scroll con virtual scrolling
3. **Image compression:** Antes de upload
4. **Debounce:** En typing indicators y search
5. **Local caching:** User data y conversations metadata

### üìä **MONITOREO - M√©tricas Frontend**

1. **Error tracking:** Sentry/LogRocket integration
2. **Performance:** Core Web Vitals monitoring
3. **User flows:** Funnel analysis para login ‚Üí message sent
4. **WebSocket health:** Connection drops y reconnections
5. **API response times:** Por endpoint y percentiles

### üîó **LINKS R√ÅPIDOS**

- **Login Flow:** `POST /api/auth/login` ‚Üí `POST /api/auth/refresh`
- **WebSocket Events:** [Ver secci√≥n 3](#3-eventos-listeners-y-l√≥gica-asincr√≥nica)
- **Error Codes:** [Ver enhancedErrorHandler.js](#6-auditor√≠a-de-logs-m√©tricas-y-errores)
- **File Upload:** `POST /api/media/upload` ‚Üí Firebase Storage URLs
- **Health Check:** `GET /health/detailed` para debugging

---

**üìû Para soporte t√©cnico o dudas sobre esta documentaci√≥n, contactar al Backend Team.**

**üîÑ √öltima actualizaci√≥n:** 2025-08-02 | **Versi√≥n del backend:** 4.1.0 Enterprise
