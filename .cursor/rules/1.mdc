---
description: 
globs: 
alwaysApply: true
---
# POLÍTICA OPERATIVA PARA IAs EN PROYECTOS (UNIK)

## Reglas obligatorias

1) NUNCA subir nada a Git hasta que lo indique explícitamente el usuario.
   - Prohibido `git push`, `merge`, `rebase` o crear PRs sin autorización previa.

2) NO recrear componentes/servicios “por simplificar”.
   - Respetar la arquitectura y reutilizar módulos existentes.

3) NO inventar rutas/endpoints ni contratos de API.
   - Usar únicamente las rutas y contratos documentados en el proyecto.

4) Siempre entregar un ANÁLISIS DE CONCLUSIONES concreto.
   - Debe incluir: hallazgos clave, riesgos, impacto, opciones y recomendación.

5) NO inventar datos ni suponer configuraciones.
   - Usar solo información disponible en el repo, archivos adjuntos y contexto dado.

## Reglas adicionales (mejora integral y prevención de errores)

6) Modo lectura por defecto.
   - Antes de tocar archivos, presentar “Propuesta de Cambios” y esperar aprobación.

7) Trabajar SOLO en el repositorio/monorepo objetivo.
   - No tocar otros repos. Identificador objetivo: <REPO_OBJETIVO>.

8) Mantener convenciones del proyecto.
   - Respetar linters, formato (Prettier), estilos de código, nomenclatura y arquitectura.

9) No eliminar lógica existente ni romper compatibilidades.
   - Aplicar cambios mínimos, reversibles y con plan de rollback.

10) No actualizar dependencias sin justificación.
   - Si es imprescindible, documentar razón, versión, CHANGELOG y pruebas asociadas.

11) Tests obligatorios para cada fix o feature tocada.
   - Unitarias e integración cuando aplique. Mantener cobertura o mejorarla.

12) Respetar contratos públicos (APIs/SDKs/Tipos).
   - Si hay breaking changes, STOP: proponer alternativa sin ruptura.

13) Validar entradas/salidas con los esquemas del proyecto (p.ej., Zod/Joi).
   - Nada entra al sistema sin validación.

14) Gestión de errores consistente.
   - Capturar, clasificar (client/server), loggear con contexto y devolver mensajes estándar.

15) Seguridad primero.
   - No exponer secretos; no hardcodear tokens; seguir OWASP Top 10 (XSS, CSRF, SQLi, etc.).

16) Telemetría y trazabilidad obligatoria.
   - Propagar `requestId`/`messageId` en logs y eventos para seguimiento extremo a extremo.

17) Performance sin regresiones.
   - Si se toca camino crítico, medir antes/después (p50/p95) y adjuntar evidencia.

18) No duplicar capas ni crear “atajos”.
   - Usar servicios/repositorios/utilidades ya existentes; prohibido crear bifurcaciones paralelas.

19) Documentar cada cambio.
   - Comentarios JSDoc cuando aplique + entrada en CHANGELOG/README del módulo tocado.

20) No cambiar infraestructura ni despliegues por cuenta propia.
   - Nada de pipelines, envs o dominios sin aprobación y plan.

21) Respetar archivos de entorno.
   - Usar `.env.example` y variables existentes; nunca subir `.env` reales.

22) Logs útiles, no ruidosos.
   - Usar el logger del proyecto con niveles `error|warn|info|debug`; sin `console.log` en prod.

23) Accesibilidad y UX.
   - No romper flujos; mantener i18n/a11y básicos si se toca UI.

24) Migraciones de datos: plan completo.
   - Describir script, idempotencia, verificación y rollback antes de tocar DB.

25) Checklist técnico PRE-PUSH/PR obligatorio.
   - `install` limpio, `type-check`, `lint --fix`, `build`, `test`, smoke local OK.

26) No cambiar nombres públicos o eventos sin mapa de compatibilidad.
   - Mantener alias/deprecaciones y fechas de remoción planificadas.

27) Mantener feature flags para cambios de riesgo.
   - Cualquier cambio sensible debe poder activarse/desactivarse sin redeploy.

28) Evitar “config drift”.
   - No modificar valores por defecto sin documentar; centralizar configuración.

29) Reutilizar contratos tipados.
   - Compartir tipos (DTOs/Interfaces) entre front/back cuando el proyecto lo contemple.

30) Todo comando destructivo requiere simulación previa.
   - Ejecutar en dry-run (si existe) y adjuntar salida en la propuesta.

31) No mover carpetas/archivos si no es estrictamente necesario.
   - Cambios de estructura requieren motivo, impacto y plan de actualización de imports.

32) Mantener compatibilidad con herramientas y versiones fijadas.
   - No cambiar Node/PNPM/TSConfig/compiladores sin aprobación.

33) No “silenciar” errores en catch.
   - Registrar contexto mínimo (requestId, input relevante, stack) y retornar estados correctos.

34) Entregables siempre reproducibles.
   - Indicar comandos exactos para correr `dev`, `test`, `build` y un smoke test.

35) Si hay dudas, priorizar evidencia.
   - Comparar contra código/README/rutas y adjuntar enlaces de líneas/archivos relevantes en el análisis.
